<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-141-环形链表]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-141%2F</url>
    <content type="text"><![CDATA[1. 题目：环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 2. 解题：使用双指针（快慢指针）。 我们知道如果一个链表有环，那么快指针一定可以追上慢指针，使它们相遇。 如果指针走到空，则说明没有环。 代码：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; ListNode fast = head; ListNode slow = head; while(fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-234-回文链表]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-234%2F</url>
    <content type="text"><![CDATA[1. 题目：回文链表 请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 2. 解题：利用快慢指针找到中点； 然后将链表的后半部分进行翻转； 判断两个部分的链表每个节点值是否相同。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) return true; ListNode slow = head; ListNode fast = head; //找中点 while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; //翻转链表 slow = reverseList(slow.next); //判断是否回文 while (slow != null) &#123; if (slow.val != head.val) return false; slow = slow.next; head = head.next; &#125; return true; &#125; //翻转函数 public ListNode reverseList(ListNode head) &#123; ListNode res = null; ListNode cur = head; while (cur != null) &#123; ListNode temp = cur.next; cur.next = res; res = cur; cur = temp; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-021-合并两个有序链表]]></title>
    <url>%2F2019%2F04%2F26%2FLeetCode-021%2F</url>
    <content type="text"><![CDATA[1. 题目：合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 2. 解题：首先，新建一个头节点，遍历l1和l2。 当l1和l2的当前节点都不为空时，比较两个节点，将小的放入head链表中； 当l2为空时，将l1剩余的节点放入head中； 当l1为空时，将l2剩余的节点放入head中； 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode cur = new ListNode(-1); ListNode head = cur; ListNode cur1 = l1; ListNode cur2 = l2; while (cur1 != null &amp;&amp; cur2 != null) &#123; if (cur1.val &lt;= cur2.val) &#123; cur.next = cur1; cur1 = cur1.next; &#125; else &#123; cur.next = cur2; cur2 = cur2.next; &#125; cur = cur.next; &#125; cur.next = (cur1 == null) ? cur2 : cur1; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-206-反转链表]]></title>
    <url>%2F2019%2F04%2F25%2FLeetCode-206%2F</url>
    <content type="text"><![CDATA[1. 题目：反转链表 反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 2. 解题：迭代解法：主要思路就是，遍历原链表，将链表的每一个节点取出，放入新链表的头结点之前，作为新的头结点。 代码：1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode res = null; ListNode cur = head; while (cur != null) &#123; ListNode temp = cur.next; cur.next = res; res = cur; cur = temp; &#125; return res; &#125;&#125; 递归解法：递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？假设列表为：n(1) → … → n(k-1) → n(k) → n(k+1) → … → n(m) → null 若从节点 n(k+1) 到 n(m) 已经被反转，而我们正处于 n(k)。 n(1) → … → n(k-1) → n(k) → n(k+1) ← … ← n(m) 我们希望 n(k+1) 的下一个节点指向 n(k)。 所以， n(k).next.next = n(k); 要小心的是 n(1) 的下一个必须指向 null。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。 代码：12345678public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-019-删除链表的倒数第N个节点]]></title>
    <url>%2F2019%2F04%2F25%2FLeetCode-019%2F</url>
    <content type="text"><![CDATA[1. 题目：删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 2. 解题：使用双指针right,left，进行一次遍历。 先让right指针走n步，然后让right和left同时出发，当right到达结尾时，left的下一个节点就是要删除节点。 需要注意，当删除的是头结点情况。 代码：123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode right = head; ListNode left = head; //right先走n步 while (n-- &gt; 0) &#123; right = right.next; &#125; //删除头节点 if (right == null) return head.next; //找到需要删除节点的前一个节点 while (right.next != null) &#123; right = right.next; left = left.next; &#125; //删除节点 left.next = left.next.next; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-237-删除链表中的节点]]></title>
    <url>%2F2019%2F04%2F25%2FLeetCode-237%2F</url>
    <content type="text"><![CDATA[1. 题目：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 2. 解题：本题和我们之前的删除节点思路不同，node就是需要删除的节点，原地删除只需要将下一个节点值复制到该节点，然后删除下一个节点即可。 1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-014-最长公共前缀]]></title>
    <url>%2F2019%2F04%2F25%2FLeetCode-014%2F</url>
    <content type="text"><![CDATA[1. 题目：最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 2. 解题：利用两次循环。 以第一个字符串开始，判断其第i字符与数组中其他字符串的第i字符是否相等。 代码：1234567891011121314151617181920class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return ""; StringBuilder strb = new StringBuilder(); for (int i = 0; i &lt; strs[0].length(); i++) &#123; char ch = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j++) &#123; if (i &lt; strs[j].length() &amp;&amp; ch == strs[j].charAt(i))&#123; continue; &#125; return strb.toString(); &#125; strb.append(ch); &#125; return strb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>公共子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-038-报数]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-038%2F</url>
    <content type="text"><![CDATA[1. 题目：报数 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 12输入: 1输出: &quot;1&quot; 示例 2: 12输入: 4输出: &quot;1211&quot; 2. 解题：首先，需要读懂题意： 报数：指的是 把当前字符串中，每个数字个个数报出 1234n = 1: 1 : 1个1 11n = 2: 11 : 2个1 21n = 3: 21 : 1个2,1个1 1211n = 4: 1211 : 1个1,1个2,2个1 111221 n的值与n-1有关 所以每次都是从１开始 两个关键：当前数字，当前数字的个数 代码：12345678910111213141516171819202122232425262728class Solution &#123; public String countAndSay(int n) &#123; //初始化第一个 String str = "1"; //从１开始，计算到n for (int i = 1; i &lt; n; i++) &#123; //用来判断当前计算完成 int k = 0; //记录每一次计算的结果 StringBuilder strB = new StringBuilder(); while (k &lt; str.length()) &#123; //当前数字 char ch = str.charAt(k); //记录当前字符的个数 int count = 0; while (k &lt; str.length() &amp;&amp; ch == str.charAt(k)) &#123; count++; k++; &#125; strB.append(count); strB.append(ch); &#125; str = strB.toString(); &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-028-实现strStr()]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-028%2F</url>
    <content type="text"><![CDATA[1. 题目：实现strStr() 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2: 12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf()) 定义相符。 2. 解题：利用substring()和equals()来实现。截取字符串并且用来比较。 代码：12345678910111213141516171819202122class Solution &#123; public int strStr(String haystack, String needle) &#123; if (needle == null || needle.length() == 0) return 0; if (haystack == null || haystack.length() == 0) return -1; int lenHay = haystack.length(); int lenNeed = needle.length(); for (int i = 0; i &lt; lenHay; i++) &#123; if (lenHay - i &lt; lenNeed) return -1; if (haystack.substring(i, i+lenNeed).equals(needle)) return i; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-008-字符串转换整数 (atoi)]]></title>
    <url>%2F2019%2F04%2F23%2FLeetCode-008%2F</url>
    <content type="text"><![CDATA[1. 题目：字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 2. 解题：对于该题分为两部分处理：处理字符串和处理整数。 处理字符串： 去掉开始的空格 判断第一个字符，来得到符号标识 遇到第一个非符号非数字的字符退出 处理整数： 需要注意溢出问题 结果返回时记住添加符号 代码：123456789101112131415161718192021222324252627282930class Solution &#123; public int myAtoi(String str) &#123; str = str.trim(); if (str == null || str.length() == 0) return 0; //符号标识 int sign = 1; //字符串索引 int i = 0; //返回值 int res = 0; //判断符号 if (str.charAt(i) == '-') &#123; sign = -1; i++; &#125; else if (str.charAt(i) == '+') &#123; sign = 1; i++; &#125; while (i &lt; str.length() &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123; // 如果`res &gt; MAX_VALUE/10`，那么`base*10 + new_value` &gt; `base*10` &gt; `MAX_VALUE`。这个应该很容易理解，这种情况下就会发生溢出。 // 若`res == MAX_VALUE/10`，而且`new_value = str.charAt(i++) - '0'`大于`7`，也会发生溢出。因为`MAX_VALUE = 2147483647 if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(i) &gt; '7')) &#123; return (sign == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; res = res * 10 + (str.charAt(i++) - '0'); &#125; return res * sign; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-125-验证回文串]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode-125%2F</url>
    <content type="text"><![CDATA[1. 题目：验证回文字符串 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 2. 解题：首先要对字符串进行处理： 大小写统一 除去多余字符，只保留数字和字母。 使用双指针，进行判断是否回文。 代码：1234567891011121314151617181920212223242526272829class Solution &#123; public boolean isPalindrome(String s) &#123; if (s == null) return true; StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if ( (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')) &#123; str.append(ch); &#125; else if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; ch = (char)(ch + 32); str.append(ch); &#125; &#125; char[] ch = str.toString().toCharArray(); int left = 0; int right = ch.length-1; while (left &lt; right) &#123; if (ch[left] != ch[right]) return false; left++; right--; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-242-有效的字母异位词]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode-242%2F</url>
    <content type="text"><![CDATA[1. 题目：有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 2. 解题：利用ASCLL码，将字符串转换成数组进行排序。 然后判断两个数组的每个元素是否相等即可。 代码：12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; char[] chS = s.toCharArray(); char[] chT = t.toCharArray(); Arrays.sort(chS); Arrays.sort(chT); for (int i = 0; i &lt; s.length(); i++) &#123; if (chS[i] != chT[i]) return false; &#125; return true; &#125;&#125; 3. 优化：利用一个额外空间char[26]，遍历第一个字符串，用数组记录每个字符的次数。 再遍历另一个字符串，对于出现的字符，数组中记录的次数减一。 最后遍历数组每一个元素是否为0. 代码：12345678910111213141516171819202122232425class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; int[] ch = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; ch[s.charAt(i) - 'a']++; &#125; for (int i = 0; i &lt; t.length(); i++) &#123; ch[t.charAt(i) - 'a']--; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (ch[i] != 0) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-387-字符串中的第一个唯一字符]]></title>
    <url>%2F2019%2F04%2F21%2FLeetCode-387%2F</url>
    <content type="text"><![CDATA[1. 题目：字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: 12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 2. 解题：使用一个大小为26的数组来存字符第一次出现的索引。 如果重复出现则将数组对应的值置为-２． 然后将数组排序，找出最小的非-1和-2，就为结果。 代码：1234567891011121314151617181920212223class Solution &#123; public int firstUniqChar(String s) &#123; int[] chars = new int[26]; Arrays.fill(chars, -1); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (chars[ch - 'a'] == -1 &amp;&amp; chars[ch - 'a'] != -2) &#123; chars[ch - 'a'] = i; &#125; else &#123; chars[ch - 'a'] = -2; &#125; &#125; Arrays.sort(chars); for (int i = 0; i &lt; 26; i++) &#123; if (chars[i] != -2 &amp;&amp; chars[i] != -1) return chars[i]; &#125; return -1; &#125;&#125; 3. 优化：利用indexOf和lastIndexOf. 代码：1234567891011121314151617class Solution &#123; public int firstUniqChar(String s) &#123; int result = -1; for(char c = 'a'; c &lt;= 'z'; c++ )&#123; // indexOf 返回此字符串中第一次出现处的索引 // lastIndexOf 返回指定字符在此字符串中最后一次出现处的索引 int idx = s.indexOf(c); // 第一次出现的索引id与最后一次出现的值相同，则满足题目要求 if(idx != -1 &amp;&amp; idx == s.lastIndexOf(c))&#123; result = (result == -1) ? idx : Math.min(result , idx); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-007-整数反转]]></title>
    <url>%2F2019%2F04%2F21%2FLeetCode-007%2F</url>
    <content type="text"><![CDATA[1. 题目：整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 2. 解题：核心就是除10，模10。但是注意两个问题：负数和溢出。 对于负数，我们使用flag变量存符号，然后取其绝对值； 对于溢出，我们利用Java的溢出机制（不抛出异常和错误，但是变成一个其他数），将res*10后再和该值除以10比较，看是否相同。 代码：1234567891011121314151617181920class Solution &#123; public int reverse(int x) &#123; int flag = (x &gt; 0) ? 1 : -1; x = (x &gt; 0) ? x : x*-1; int res = 0; int temp = 0; while(x &gt; 0) &#123; res *= 10; if (res / 10 != temp) &#123; return 0; &#125; res += x%10; temp = res; x /= 10; &#125; return res*flag; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>整数反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-344-反转字符串]]></title>
    <url>%2F2019%2F04%2F21%2FLeetCode-344%2F</url>
    <content type="text"><![CDATA[1. 题目：反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 2. 解题：原地翻转，就是使用交换即可。 代码：123456789101112class Solution &#123; public void reverseString(char[] s) &#123; if (s == null || s.length &lt;= 1) return; int len = s.length; for (int i = 0; i &lt; len/2; i++) &#123; char temp = s[i]; s[i] = s[len-1-i]; s[len-i-1] = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-048-旋转图像]]></title>
    <url>%2F2019%2F04%2F20%2FLeetCode-048%2F</url>
    <content type="text"><![CDATA[1. 题目：旋转图像 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 2. 解题：不能使用额外空间，因此我们需要通过交换完成。分两步： 以矩阵的中心列为对称轴，进行翻转（实际上进行交换）； 以翻转后矩阵的副对角线为对称轴，进行翻转。 代码：1234567891011121314151617181920212223class Solution &#123; public void rotate(int[][] matrix) &#123; int row = matrix.length; int col = matrix[0].length; //以中心列为轴进行翻转，也就是交换元素 for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col / 2; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[i][col - 1 - j]; matrix[i][col - 1 - j] = temp; &#125; &#125; //以副对角线为轴进行翻转 for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j&lt; col - i; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[col - 1 - j][row - 1 - i]; matrix[col - 1 - j][row - 1 - i] = temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-036-有效的数独]]></title>
    <url>%2F2019%2F04%2F20%2FLeetCode-036%2F</url>
    <content type="text"><![CDATA[1. 题目：有效的数独 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2: 123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。 2. 解题：本题要求比较简单只需要判断给出的数独是否有效即可。 大体思路分为三部分： 每行中不能出现重复的数字； 每列中不能出现重复的数字； 每个3*3方格中不能出现重复数字。 因此我们使用Set来判断是否有重复的数字。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; Set&lt;Character&gt; cols = new HashSet&lt;&gt;(); Set&lt;Character&gt; rows = new HashSet&lt;&gt;(); Set&lt;Character&gt; blocks = new HashSet&lt;&gt;(); int row = board.length; int col = board[0].length; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; //检查行 if (board[i][j] != '.') &#123; if (rows.contains(board[i][j])) &#123; return false; &#125; else &#123; rows.add(board[i][j]); &#125; &#125; //检查列 if (board[j][i] != '.') &#123; if (cols.contains(board[j][i])) &#123; return false; &#125; else &#123; cols.add(board[j][i]); &#125; &#125; &#125; rows.clear(); cols.clear(); &#125; //检查方块 for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j&lt; 3; j++) &#123; for (int m = i * 3; m &lt; i * 3 + 3; m++) &#123; for (int n = j * 3; n &lt; j * 3 + 3; n++) &#123; if (board[m][n] != '.') &#123; if (blocks.contains(board[m][n])) &#123; return false; &#125; else &#123; blocks.add(board[m][n]); &#125; &#125; &#125; &#125; blocks.clear(); &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数独问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-001-两数之和]]></title>
    <url>%2F2019%2F04%2F19%2FLeetCode-001%2F</url>
    <content type="text"><![CDATA[1. 题目：两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 2. 解题：求两数之和a + b = target，实际上就是查找a = target - b，转换成找一个数的思想。 使用HashMap来解决查找问题，key用来存数组中的元素，value来存元素的索引。 我们使用边插入边查找： 遍历数组，检查target - nums[i]是否在map中， 如果在则返回结果； 如果不在则将该元素插入map中。 代码：1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(target - nums[i])) &#123; return new int[]&#123;i, map.get(target - nums[i])&#125;; &#125; else &#123; map.put(nums[i], i); &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-283-移动零]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-283%2F</url>
    <content type="text"><![CDATA[1. 题目：移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 2. 解题：本题要求将0移动到数组末尾，并且要求非零相对顺序不变。实际上就是让我们将非零元素移到数组头部。 使用双指针indexZero(记录第一个0的索引)和indexNoZero(记录为移动的第一个非零的索引)。 当indexZero &lt; indexNoZero时，则将其“交换”（实际上只需要赋值，并不用真正交换）； 当indexZero &gt; indexNozero时，不要交换，继续找下一个非零元素。 注意只有非零元素和只有零元素的情况。 代码：1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public void moveZeroes(int[] nums) &#123; if (nums == null || nums.length == 0) return; int indexZero = 0; int indexNoZero = 0; while (indexNoZero &lt; nums.length - 1) &#123; //找到第一个0元素 while (nums[indexZero] != 0) &#123; indexZero++; if (indexZero == nums.length -1) return; &#125; //找到第一个非零元素 while (nums[indexNoZero] == 0) &#123; indexNoZero++; //最右边是零元素j if (indexNoZero == nums.length) return; &#125; //如果０在非零前边，则他们交换，否则，非零索引前进 if (indexZero &lt; indexNoZero) &#123; nums[indexZero] = nums[indexNoZero]; nums[indexNoZero] = 0; &#125; else &#123; indexNoZero++; &#125; &#125; &#125;&#125; 3. 优化1234567891011121314class Solution &#123; public void moveZeroes(int[] nums) &#123; int index = 0; int length = nums.length; for (int i = 0; i &lt; length; i++) &#123; if (nums[i] != 0) &#123; nums[index++] = nums[i]; &#125; &#125; for (int i = index; i &lt; length; i++) &#123; nums[i] = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-066-加一]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-066%2F</url>
    <content type="text"><![CDATA[1. 题目：加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 2. 解题：这个题主要思路从数组的最后一个元素开始加一，然后看是否进位。 若进位，则给数组的前一个元素加一，判断是否进位，重复此动作； 若不进位，则加一完成。 需要注意：当出现9,99,999...这种情况时，需要重新创建一个数组，使其第一个元素为1. 代码：12345678910111213141516171819202122232425class Solution &#123; public int[] plusOne(int[] digits) &#123; int len = digits.length; int carry = 1; int i = len - 1; while(carry == 1 &amp;&amp; i &gt;= 0) &#123; int num = digits[i] + carry; carry = 0; if (num == 10) &#123; carry = 1; digits[i] = 0; i--; &#125; else &#123; digits[i] = num; &#125; &#125; if (carry == 1) &#123; int[len+1] res = new int[len+1]; res[0] = 1; return res; &#125; return digits; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-350-两个数组的交集 II]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-350%2F</url>
    <content type="text"><![CDATA[1. 题目：两个数组的交集 II 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 2. 解题：使用ArrayList来存放重复元素。 将两个数组排序，使用两个指针i、j来遍历两个数组，当其中一个数组遍历完时结束。 当nums1[i] == nums2[j]，将该元素加入到ArrayList，并且i++, j++； 当nums1[i] &lt; nums2[j]，i++； 当nums1[i] &gt; nums2[j]，j++。 最后再将ArrayList转换成int[]。 代码：1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) return null; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len1 = nums1.length; int len2 = nums2.length; int i = 0; int j = 0; Arrays.sort(nums1); Arrays.sort(nums2); while (i &lt; len1 &amp;&amp; j &lt; len2) &#123; if (nums1[i] == nums2[j]) &#123; list.add(nums1[i]); j++; i++; &#125; else if (nums1[i] &lt; nums2[j]) &#123; i++; &#125; else &#123; j++; &#125; &#125; int[] res = new int[list.size()]; for (int k = 0; k &lt; list.size(); k++) &#123; res[k] = list.get(k); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-136-只出现一次的数字]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode-136%2F</url>
    <content type="text"><![CDATA[1. 题目：只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 2. 解题：关键是只有一个元素出现一次，其余元素均出现两次。因此，我们可以使用位运算： 0 ^ num = num； n ^ num ^ num = n； 代码：12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; res ^= nums[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-217-存在重复]]></title>
    <url>%2F2019%2F04%2F17%2FLeetCode-217%2F</url>
    <content type="text"><![CDATA[1. 题目：给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 2. 解题：解法一：主要就是找有没有重复的元素，因此我们可以使用HashMap，将元素作为key，用来判断map中是否存在该元素，若存在则返回true，若不存在则将该元素加入map。 代码：1234567891011121314151617class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; if (nums == null || nums.length == 0) return false; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) &#123; return true; &#125; map.put(nums[i], null); &#125; return false; &#125;&#125; 解法二：先排序，然后找相同的。将元素排列好，判断相邻两个元素是否相同。 代码：12345678910class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Arrays.sort(nums); for (int i = 0; i &lt; nums.length-1; i++) &#123; if (nums[i] == nums[i+1]) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>重复元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-189-旋转数组]]></title>
    <url>%2F2019%2F04%2F17%2FLeetCode-189%2F</url>
    <content type="text"><![CDATA[1. 题目：旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 2. 解题：使用三次倒置， 第一次整个数组倒置； 以第k个元素为中心将数组分为两部分， 第二次前部分数组倒置； 第三次后部分数组倒置。 主要注意，当k &gt; nums.length时，需要对k进行k = k % nums.length处理。 12345678假设数组 0 1 2 3 4 5 6k = 2结果 5 6 0 1 2 3 4以length-k为界限，将数组分为两部分 0 1 2 3 4 ， 5 6现将前部分倒置 4 3 2 1 0 5 6再将后部分倒置 4 3 2 1 0 6 5将整个部分倒置 5 6 0 1 2 3 4 代码：1234567891011121314151617181920212223class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k == 0) return; k = k % nums.length; reverse(nums, 0, nums.length-1); reverse(nums, 0, k-1); reverse(nums, k, nums.length-1); &#125; private void reverse(int[] nums, int start, int end) &#123; int left = start; int right = end; while(left &lt; right) &#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125;&#125; 3. 其他解法：1234567891011121314151617181920212223242526272829/** * 每次移动1个位置 * 移动k次 * */public void rotate(int[] nums, int k) &#123; int temp, kk; kk = k%nums.length; for (int i = 0; i &lt; kk; i++) &#123; temp = nums[nums.length-1]; for (int j = nums.length-1; j &gt; 0; j--) &#123; nums[j] = nums[j-1]; &#125; nums[0] = temp; &#125;&#125;/** * 新建一个等大数组，用空间换取时间 * */public void rotate2(int[] nums, int k) &#123; int[] new_nums = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; new_nums[(i+k)%nums.length] = nums[i]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = new_nums[i]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-122-LeetCode-122-买卖股票的最佳时机 II]]></title>
    <url>%2F2019%2F04%2F17%2FLeetCode-122%2F</url>
    <content type="text"><![CDATA[1. 题目：买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2. 解题：可以多次买卖，那么我们实际上是求相邻两个之间差值大于0的和。 代码：1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int res = 0; for (int i = 0; i &lt; prices.length-1; i++) &#123; if (prices[i] &lt; prices[i+1]) &#123; res += (prices[i+1] - prices[i]); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-026-从排序数组中删除重复项]]></title>
    <url>%2F2019%2F04%2F17%2FLeetCode-026%2F</url>
    <content type="text"><![CDATA[LeetCode-026-从排序数组中删除重复项1. 题目：从排序数组中删除重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 2. 解题：使用双指针。一个慢指针res用来记录不同元素，一个快指针i用来遍历整个数组。 res初始化为0,i初始化为1; 当nums[res] != nums[i]时，res++说明增加一个不同的元素，再将nums[i]赋给nums[res]； 当nums[res] == nums[i]时，增加i来跳过重复项。 代码：1234567891011121314151617class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int res = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[res]) &#123; res++; nums[res] = nums[i]; &#125; &#125; return res+1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-347-前K个高频元素]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode-347%2F</url>
    <content type="text"><![CDATA[１.题目：前K个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 ２.解题：​ 要求我们找到数组中出现频率最高的前k的元素，因此我们需要知道每个元素出现的次数。 ​ 我们选择使用Map&lt;key, value&gt;来存数组中的元素和其出现的次数。 ​ 我们需要按照value来排序，为了满足时间复杂度 O(n log n) ，我们选择使用大顶堆排序（PriorityQueue）。我们要注意的是：PriorityQueue默认是小顶堆，因此我们需要重写一个新的比较器。 ​ 然后将queue中的前ｋ个元素拿出来放入List中。 代码：12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; //结果List List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //map用来存放数组中元素和其出现次数的映射 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //使用大顶堆对map中元素排序 PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123; //重写比较器 @Override public int compare(Map.Entry&lt;Integer, Integer&gt; t1, Map.Entry&lt;Integer, Integer&gt; t2) &#123; return t2.getValue() - t1.getValue(); &#125; &#125;); //遍历数组 for (int num : nums) &#123; if (!map.containsKey(num)) &#123; //map中不存在该元素 map.put(num, 1); &#125; else &#123; //map中存在该元素 map.put(num, map.get(num)+1); &#125; &#125; //将map中的元素放入大顶堆中 for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; queue.offer(entry); &#125; //取出大顶堆中的前k个元素 for (int i = 0; i &lt; k; i++) &#123; result.add(queue.poll().getKey()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-075-颜色分类]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode-075%2F</url>
    <content type="text"><![CDATA[LeetCode-075-ColorClassification１．题目：颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ ２．解题​ 只为AC(手动滑稽)，因为题目要求颜色排序，颜色用数字代替，顺序正好从小到大，这实际上就是一道数组排序题，因此排序算法都可以使用，这里选择最简单的冒泡排素． 代码：12345678910111213class Solution &#123; public void sortColors(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] &gt; nums[j]) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; &#125; &#125;&#125; ３．优化：​ 采用三路快排的思想，因为有0, 1, 2，三个数，如果我们让0到达最左边，让2到达最右边，那么1自然最在中间部分． ​ 首先我们需要两个指针：left：用来指到最左边0的下一个位置；right：用来指到最右边２的上一个位置． ​ 然后遍历数组，如果发现nums[i] == 0，则将left和i的值交换并且left++；如果发现nums[i] == 2，则将right和i的值交换并且right--，此时要注意交换后的数是什么． ​ 要注意，i最多取到right的位置． 代码：1234567891011121314151617181920212223242526class Solution &#123; public void sortColors(int[] nums) &#123; //左指针 int left = 0; //右指针 int right = nums.length-1; for (int i = 0; i &lt;= right; i++) &#123; if (nums[i] == 0) &#123; swap(nums, i, left); left++; &#125; else if(nums[i] == 2) &#123; swap(nums, i, right); right--; //要判断交换过来的数是什么 i--; &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-079-WordSearch]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode-079%2F</url>
    <content type="text"><![CDATA[LeetCode-079-WordSearch１．题目：单词搜索 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. ２．解题：​ 首先这个类似于迷宫问题，当单词的第一个字母在board匹配后，判断其位置的上下左右（考虑边界）是否可以匹配单词的下一个字母．我们为了实现这个过程，需要使用DFS． ​ 由于同一个单元格内的字母不允许重复使用，因此我们需要使用额外的空间来记录被访问过的单元格． ​ 现在我们来考虑递归退出条件．退出的情况无非两种：成功退出，当我们找到单词所有的字母时表示我们成功找到，此时使用一个计数器count用来表示成功匹配的字母数，满足count == word.length()；另一种情况就是找完所有情况不满足匹配，自动退出． 代码：123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public boolean exist(char[][] board, String word) &#123; if (board == null || (board.length == 0 &amp;&amp; board[0].length == 0)) return false; int row = board.length; int col = board[0].length; boolean[][] visited = new boolean[row][col]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (wordDFS(board, visited, 0, i, j, word)) &#123; return true; &#125; &#125; &#125; return false; &#125; private boolean wordDFS(char[][] board, boolean[][] visited, int count, int row, int col, String word) &#123; //退出条件 if (count == word.length()) &#123; return true; &#125; //判断边界 if (row &lt; 0 || col &lt; 0 || row &gt;= board.length || col &gt;= board[0].length) &#123; return false; &#125; //需要匹配的字符 char ch = word.charAt(count); if (!visited[row][col] &amp;&amp; ch == board[row][col]) &#123; visited[row][col] = true; //判断下一个能否找见 boolean next = (wordDFS(board, visited, count+1, row + 1, col, word) || wordDFS(board, visited, count+1, row - 1, col, word) || wordDFS(board, visited, count+1, row, col + 1, word) || wordDFS(board, visited, count+1, row, col - 1, word)); visited[row][col] = false; return next; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-078-Subsets]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode-078%2F</url>
    <content type="text"><![CDATA[LeetCode-078-Subsets１．题目：子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] ２．解题​ 这是一个传统的求集合子集的问题，需要注意：不要忘掉空子集；集合中不能有重复元素，包括子集也不能有重复元素． ​ 对于这道题我们可以使用递归的思想解答： ​ 我们先来观察几组结果 123456789101112131415输入：nums = [];结果：[[]];输入：nums = [1];结果：[[], [1] ]; 输入：nums = [1, 2];结果：[ [], [1], [2], [1, 2], ] ​ 我们发现，实际上nums = [1]的解就是在num = []的所有解上加上1；nums = [1, 2]的解就是在num = [1]的所有解上加上2；所以我们只需要遍历nums中的每一个元素，并将解集 result中的每一个解加上num[i]作为新的解集添加到新的解集中． 代码：12345678910111213141516171819202122232425262728293031class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return result; &#125; //先添加空子集 result.add(new ArrayList&lt;&gt;()); //遍历每一个元素 for (int i = 0; i &lt; nums.length; i++) &#123; //添加新的子集 subsetsAppend(result, nums[i]); &#125; return result; &#125; /** * * @param lists 解集 * @param num 被添加的元素 */ private static void subsetsAppend(List&lt;List&lt;Integer&gt;&gt; lists, int num) &#123; //需要记录子＝解集进入函数时的长度，下边会向子＝解集中添加新的解，会导致长度改变 int len = lists.size(); for (int i = 0; i &lt; len; i++) &#123; //得到新的解 List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(lists.get(i)); temp.add(num); lists.add(temp); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>子集问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-046-Permutations]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-046%2F</url>
    <content type="text"><![CDATA[LeetCode-046-Permutations１．题目：全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] ２．解题：​ 这是全排列问题，需要找出所有符合条件的结果，所以我们可以使用回溯算法，我们来考虑回溯三要素： ​ 选择：选择的对象是数列中的每个元素，可以使用for循环； ​ 限制：list中不能出现重复的元素； ​ 退出条件：当list.size() == nums.length时，将list的值加入到解集中lists． 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return result; &#125; permuteDFS(result, new ArrayList&lt;&gt;(), nums); return result; &#125; /** * * @param lists 解集 * @param list 当前解集的值 * @param nums 需要被排序的数列 */ private static void permuteDFS(List&lt;List&lt;Integer&gt;&gt; lists, List&lt;Integer&gt; list, int[] nums) &#123; //退出条件 if (list.size() == nums.length) &#123; /* * 这里一定要重新创建ArrayList对象，不能直接添加list * 因为下边的list.remove(list.size() - 1);会改变list中的数据． */ lists.add(new ArrayList&lt;&gt;(list)); return; &#125; //遍历数列 for (int i = 0; i &lt; nums.length; i++) &#123; if (!list.contains(nums[i])) &#123; list.add(nums[i]); permuteDFS(lists, list, nums); list.remove(list.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-022-GenerateParenthesis]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-022%2F</url>
    <content type="text"><![CDATA[LeetCode-022-GenerateParenthesis１．题目生成括号 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] ２．解题：​ 需要找出所有解，所以我们可以使用回溯法，使用递归找出所有合适的解． 回溯（Backtracking）算法思路：在当前局面下，你有若干种选择。逐一尝试每一种选择。如果发现某种选择行不通（违反了某些限定条件）就返回；如果某种选择试到最后发现是正确解，就将其加入解集。 使用递归解决问题需要明确以下三点： 选择 (Options) 、 限制 (Restraints) 和 结束条件 (Termination) 。即“ORT原则”。 ​ 来回到本题： ​ 选择：两个选择：加左括号，加右括号． ​ 限制：１．如果左括号用完，则不能添加左括号． ​ ２．始终保证左括号＜＝右括号，这样才能保证括号匹配．因此当左右括号一样多 时，不能添加右括号． ​ 结束条件：当左右括号都为零时，则表示找到一个解． 代码：12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; //解集 List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(n &lt;= 0) &#123; return result; &#125; genParenthesis(result, "", n, n); return result; &#125; /** * @param list 解集 * @param s 当前解 * @param leftNum 左括号数 * @param rightNum 右括号数 */ private void genParenthesis(List&lt;String&gt; list, String s, int leftNum, int rightNum) &#123; //如果左右括号同时为0时，说明找到一个解并加入解集 if (leftNum == 0 &amp;&amp; rightNum == 0) &#123; list.add(s); return; &#125; //如果左括号＞零，则加一个左括号，继续递归 if (leftNum &gt; 0) &#123; genParenthesis(list, s+"(", leftNum-1, rightNum); &#125; //如果左括号＜右括号，则加一个右括号，继续递归 if (leftNum &lt; rightNum) &#123; genParenthesis(list, s+")", leftNum, rightNum-1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>括号问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-017-LetterCombinationOfAPhoneNumber]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-017%2F</url>
    <content type="text"><![CDATA[LeetCode-017-LetterCombinationOfAPhoneNumber１．题目：电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 ２．解答​ 需要找出所有数字所对应的字母的自由组合，实际上就是一个求全排列的问题，使用递归算法来求解，需要考虑退出问题． ​ 第一步：拿出当前字符串第一个字符（数字），找出其所对应的所有字母firstNum； ​ 第二步：取当前字符串的除去第一个字符的剩下的字符串； ​ 第三步：对新的字符串进行letterCombinations()处理得到leftNum； ​ 第四步：将firstNum和 leftNum的元素自由组合； ​ 第五步：退出条件是当字符串只有一个元素的时候，返回当前字符串的一个字符对应的字母的String[]. ​ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; //数字对应的字母表 public static String[][] letterTable = new String[][]&#123; &#123;"a", "b", "c"&#125;, &#123;"d", "e", "f"&#125;, &#123;"g", "h", "i"&#125;, &#123;"j", "k", "l"&#125;, &#123;"m", "n", "o"&#125;, &#123;"p", "q", "r", "s"&#125;, &#123;"t", "u", "v"&#125;, &#123;"w", "x", "y", "z"&#125;, &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (digits.length() == 0) return result; //利用ASCLL,将char转化成int类型的索引，找到当前第一个字符对应的letterTable String[] firstNum = letterTable[digits.charAt(0) - 48 - 2]; //当前字符串只有一个 if (digits.length() == 1) &#123; result.addAll(Arrays.asList(firstNum)); return result; &#125; //使用递归，回溯处理除去当前第一个字符的字符串 List&lt;String&gt; leftNum = letterCombinations(digits.substring(1)); //将firstNum 和 leftNum的元素自由组合 for (String str : firstNum ) &#123; for (String str2 : leftNum) &#123; result.add(str + str2); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-200-NumberOfLands]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-200%2F</url>
    <content type="text"><![CDATA[LeetCode-200-NumberOfLands１．题目：岛屿的个数 给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 ２．解答：​ 我们需要在矩阵中找到由&#39;１&#39;组成的陆地，当我们从一个点出发时，需要判断它的上下左右４点是否为&#39;1&#39;，如果有为&#39;1&#39;的点，则重复上述动作；若出现不为&#39;1&#39;，则说明到达陆地边界．这实际上就是对一个点进行深度遍历，递归查找为&#39;1&#39;点，直到找到整个陆地． ​ 我们需要注意的是，我们可能会重复遍历同一个点，为了解决这个问题，当我们已经确定当前点为&#39;1&#39;时，我们将它置为&#39;0&#39;. ​ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int numIslands(char[][] grid) &#123; //陆地个数 int count = 0; if (grid == null || grid.length == 0 || grid[0].length == 0) return count; //矩阵行数 int row = grid.length; //矩阵列数 int col = grid[0].length; //遍历矩阵 for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (grid[i][j] == '1') &#123; count++; dfsSearch(grid, i, j, row, col); &#125; &#125; &#125; return count; &#125; /** * 深度遍历，查找该点四周是否为'1' * @param grid 矩阵 * @param i 当前点的行号 * @param j 当前点的列号 * @param row 矩阵的行数 * @param col 矩阵的列数 */ private void dfsSearch(char[][] grid, int i, int j, int row, int col) &#123; //判断是否在矩阵内 if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col) &#123; return; &#125; //判断是否为＂陆地＂ if (grid[i][j] != '1') return; //将该点置为'0'，表示已经访问过该点 grid[i][j] = 0; //判断该点四周是否为＂陆地＂ dfsSearch(grid, i, j+1, row, col); dfsSearch(grid, i, j-1, row, col); dfsSearch(grid, i+1, j, row, col); dfsSearch(grid, i-1, j, row, col); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>深度遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-230-二叉搜索树中第K小的元素]]></title>
    <url>%2F2019%2F04%2F14%2FLeetCode-230%2F</url>
    <content type="text"><![CDATA[LeetCode-230-二叉搜索树中第K小的元素1. 题目：二叉搜索树中第K小的元素 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2: 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 2. 解题：二叉搜索树的中序遍历的结果就是从小到大的有序顺序。因此我们要找到第k小的元素，那就是中序遍历第k个节点的值。 代码：123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int result = 0; private int count = 0; public int kthSmallest(TreeNode root, int k) &#123; inorder(k, root); return result; &#125; private void inorder(int k, TreeNode root) &#123; if (root == null) return; if (root.left != null) &#123; inorder(k, root.left); &#125; if (++count == k) &#123; result = root.val; return; &#125; if (root.right != null) &#123; inorder(k, root.right); &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>中序遍历</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-116-填充每个节点的下一个右侧节点指针]]></title>
    <url>%2F2019%2F04%2F14%2FLeetCode-116%2F</url>
    <content type="text"><![CDATA[LeetCode-116-填充每个节点的下一个右侧节点指针1. 题目：填充每个节点的下一个右侧节点指针 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 12345输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 2. 解题：其实这个题的核心依旧是层次遍历。对于每一层从左到右依次连接，最右节点链接NUll. 用Queue来存节点，用num和next来记录每层节点数。 对于每层的节点处理分两种情况：最有一个节点和非最后一个节点。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val,Node _left,Node _right,Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null) return null; //用来存放节点 Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); // 当前层节点数，初始化为第一层 int num = 1; // 下一层节点数 int next = 0; // 开始层序遍历 while (!queue.isEmpty()) &#123; Node node = queue.poll(); num--; //添加左节点 if (node.left != null) &#123; queue.offer(node.left); next++; &#125; //添加右节点 if (node.right != null) &#123; queue.offer(node.right); next++: &#125; //不是当前层最后一个，指向queue的第一个 if (num != 0 &amp;&amp; !queue.isEmpty()) &#123; node.next = queue.peek(); &#125; //当前层最后一个指向null if (num == 0) &#123; node.next = null; num = next; next = 0; &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈final关键字]]></title>
    <url>%2F2019%2F04%2F13%2Ffinal%2F</url>
    <content type="text"><![CDATA[浅谈final关键字final关键字的含义？final是Java中一个保留的关键字。可以声明变量、方法、类，虽然在不同的场景下有细微区别，但总体上都是指，“是不可变的”。 final修饰变量我们经常会使用到“常量”，在Java中，用final修饰过的变量，只能进行一次赋值操作，并且在生存周期中不能改变它的值。 需要注意，final会告诉编译器，这个数据不会修改，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。如果进行一次赋值操作后，再次进行一次赋值，这时编译不通过。 final变量只可读。 123456public static void main(String[] args) &#123; final int a = 1; a = 2; //编译错误 final String s = "A"; s = "B"; //编译错误 &#125; 对于基本类型变量和引用变量，其效果有些区别： 123456789101112131415161718192021class ClassA &#123; int value = 0;&#125;public class Main &#123; public static void main(String[] args) &#123; /* 声明赋值一起 */ final int a = 1; //a = 4 编译失败 /* 先声明，后赋值 */ final int b; b = 2; final ClassA A= new ClassA(); //A = new ClassA(); 编译失败 System.out.println(A.value); //输出：0 A.value = 1; System.out.println(A.value); //输出：1 &#125;&#125; 我们发现对于a我们不能进行重新赋值，使｀a｀成为常量。但对于A.value我们进行了从新赋值。这时因为对于基本数据类型，一旦被final修饰，就不能改变其值；对于引用类型，只是限定引用变量的引用不可改变，“引用”实际上就是一个“地址”，但是该地址所对应的内存空间内的值是可以改变的。 对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。 12345678public class Main &#123; public static void main(String[] args) &#123; final List list = new ArrayList(); list.add(1); //有效操作 list.add(2); //有效操作 list = new ArrayList(); //编译失败 &#125;&#125; 对于final修饰变量的初始化赋值：可以声明时赋值，也可以在构造函数中初始化赋值。 ### 对于final修饰变量的初始化赋值：可以声明时赋值，也可以在构造函数中初始化赋值。 final修饰方法的参数对于自己创建的变量，我们知道只能赋值一次，那对方法参数进行final修饰呢？ 它表示在整个方法中，我们不会（实际上不能）改变参数的值。 12345678910public class Main &#123; public static void main(String[] args) &#123; /.../ &#125; public void fun(final int num) &#123; //num = 1; 不允许 int a = num; a = 2; &#125;&#125; final修饰方法用final关键字也可以修饰方法，它表示该方法不能被子类方法重写。如果一个方法已经确定不需要修改，可以声明为final，这样会提高效率，因为final方法在编译时就已经静态绑定了，不需要在运行时动态绑定。 关于private和final关键字有一点联系，类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法重写它。 final修饰类使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。 不可变类创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等。 final与String类的不可变性相关阅读：String类的不可变性 我们先来看一个例子： 123456789101112public class Main &#123; public static void main(String[] args) &#123; final String s1 = "A"; System.out.println(s1); //A s.replace("A", "B"); System.out.println(s1); //A System.out.println(s1.replace("A", "B")); &#125;&#125; 首先我们发现s1的值并没有改变，这就是String的不可变形，我们平时说“String是字符串常量”也是这个意思，在源码中String类本身就被final修饰过，所以可以这么说，用final修饰的String类型，它就不能再改变了，正如上述例子s1将一直是A。 而对于replace()方法，其底层源码是返回一个new StringBuilder.toString().相当于是一个新的String.]]></content>
      <categories>
        <category>Java</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类的不可变性]]></title>
    <url>%2F2019%2F04%2F13%2FString-1%2F</url>
    <content type="text"><![CDATA[String类的不可变性1.什么是不可变性？​ Java中的String类是不可变的．那么一般对不可变对象的理解是：如果一个对象，在它创建完成后，不能再改变它的状态，则这个对象是不可变的． ​ 不能改变状态是指，不能改变对象内部的成员变量，包括基本数据类的值不能变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变． 2.区分对象和对象的引用123456String s = "Djt";System.out.println("s = " + s);//结果：s = Djts = "djt";System.out.println("s = " + s);//结果 s = djt ​ 从上边的代码可看出，s的结果发生了改变．那么和String类的不可变性是矛盾的码？这里是一个误区，我们说的不可变性是指String对象的不可变性，而这里的s只是一个String对象的引用，并不是对象本身． ​ 对象时在内存中的一块内存，内存的大小根据对象中成员变量的多少来决定；引用只是一个４字节的数据，里边存放着它所指的对象的地址，通过这个地址可以访问对象． ​ 对象就像是一个屋子，对象的地址就好比时屋子的钥匙，而引用只是用来装钥匙的盒子，所以上边的代码中，s第一次装的是＂Djt＂的＂钥匙＂，第二次装的是＂djt＂的＂钥匙＂，但是屋子以及屋子里的东西没有改变． 3.String类的不可变性​ 对于String类的不可变性，主要是因为源码中，其内部使用了private final修饰成员．]]></content>
      <categories>
        <category>Java</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-105-从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode-105%2F</url>
    <content type="text"><![CDATA[LeetCode-105-从前序与中序遍历序列构造二叉树1. 题目：从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 2. 解题：我们知道，前序遍历是先遍历根节点，再遍历左子树，最后遍历右子树，因此我们知道前序遍历的顺序中第一个一定是根节点； 而中序遍历是先遍历左子树，再遍历根节点，最后遍历右子树，因此在中序遍历的顺序中找到根节点，则根节点前方就是左子树的中序遍历顺序，根节点后方就是右子树的遍历顺序。 简单来说： 前序遍历顺序 ＝ 根节点 ＋ 左子树的前序遍历 ＋ 右子树的前序遍历； 中序遍历顺序 ＝ 左子树的中序遍历 ＋ 根节点 ＋ 右子树的中序遍历； 那么前序遍历用来找“根节点”，中序遍历用来找左子树的个数和右子树的个数。 123456过程：第一步：通过前序遍历找到根结点（pre[0]）第二步：在中序遍历中找到根结点的索引第三步：在in[]中，根据根结点索引的左右可以找到左右子树的个数第四步：在pre[]中找到左右子树的pre[]第五步：重复上述步骤 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder == null || inorder == null) return null; if (preorder.length * inorder.length == 0) return null; if (preorder.length != inorder.length) return null; return inorderAndPreorderBuild(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1); &#125; private TreeNode inorderAndPreorderBuild(int[] pre, int preBegin, int preEnd, int[] in, int inBegin, int inEnd) &#123; if (preBegin &gt; preEnd || inBegin &gt; inEnd) return null; //根结点就是前序遍历的第一个结点 TreeNode root = new TreeNode(pre[preBegin]); //只有一个节点 if (preBegin == preEnd) return root; //在中序遍历中查找根结点的位置 int index = -1; for (int i = inBegin; i &lt;= inEnd; i++) &#123; if (pre[preBegin] == in[i]) &#123; index = i; break; &#125; &#125; //左子数结点个数 int leftNum = index - inBegin; //右子树结点个数 int rightNum = inEnd - index; //找根节点的左子树 root.left = inorderAndPreorderBuild(pre, preBegin+1, preBegin+leftNum, in, inBegin, index-1); //找根节点的右子树 root.right = inorderAndPreorderBuild(pre, preEnd-rightNum+1, preEnd, in, index+1, inEnd); return root; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>中序遍历</tag>
        <tag>前序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-103-二叉树的锯齿形层次遍历]]></title>
    <url>%2F2019%2F04%2F12%2FLeetCode-103%2F</url>
    <content type="text"><![CDATA[LeetCode-103-二叉树的锯齿形层次遍历1. 题目：给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 2. 解题：首先是二叉树的层次遍历，我们知道使用队列。 但是需要注意的是： ​ ａ）锯齿状，先从左往右，再从右往左进行下一层遍历，因此我们需要知道每一层的遍历方向。使用一个boolean变量leftToRight。 ​ ｂ）每一层元素使用一个ArrayList存放。因此我们需要知道何时一层开始，何时一层结束。使用两个变量，当前层数量num，下一层数量next，num == 0时，表示当前层结束。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; //结果 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; //一层的值 List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //用来存放一层结点的队列 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); //leftToRight从左到右 boolean leftToRight = true; queue.offer(root); //当前层中结点个数 int num = 1; //下一层中结点个数 int next = 0; //队列为空表示结束 while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); num--; //加入左节点 if (node.left != null) &#123; queue.offer(node.left); next++; &#125; //加入右节点 if (node.right != null) &#123; queue.offer(node.right); next++; &#125; //判断遍历方向 if (leftToRight) &#123; list.add(node.val); &#125; else &#123; ((LinkedList&lt;Integer&gt;) list).addFirst(node.val); &#125; //一层结束 if (num == 0) &#123; num = next; next = 0; leftToRight = !leftToRight; result.add(list); list = new LinkedList&lt;&gt;(); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-621-任务调度器]]></title>
    <url>%2F2019%2F04%2F11%2FLeetCode-621%2F</url>
    <content type="text"><![CDATA[LeetCode-621-任务调度器1. 题目：Task Scheduler 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例 1： 123输入: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 注： 任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。 2. 解题：我们求最短时间，优先完成任务最多的，在完成数量最多的任务间隔中穿插其他任务或等待。 先来明确几个变量： n：是间隔 max：个数最多的任务的数量。例如，[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;]，max = 3. maxCount：有多少个最大数量；例如，[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]，maxCount = 2. 当出现等待的时候，我们可以计算出最短时间为：(max-1)*(n+1)+maxCount 当没有出现等待时，(max-1)*(n+1)+maxCount会小于tasks.length，也就是说明最大任务 的间隔由其他任务填满，此时最小时间就是tasks.length。 代码：12345678910111213141516171819202122232425class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if (n == 0) return tasks.length; int[] counts = new int[26]; int len = counts.length; for (int i = 0; i &lt; tasks.length; i++) &#123; counts[tasks[i] - 'A']++; &#125; Arrays.sort(counts); int max = 0; int maxCount = 0; max = counts[len - 1]; // 找最大任务的个数 for (int i = len - 1; i &gt;= 0; i--) &#123; if (max == counts[i]) &#123; maxCount++; continue; &#125; break; &#125; int res = (max-1)*(n+1)+maxCount; return res &gt; tasks.length ? res : tasks.length; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>任务调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-169-求众数]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode-169%2F</url>
    <content type="text"><![CDATA[LeetCode-169-求众数1. 题目：求众数 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 2. 解题：解题的关键在[n/2]，则我们可以将数组排序，取数组中间位置即可。 代码：123456class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>众数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-150-逆波兰表达式求值]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode-150%2F</url>
    <content type="text"><![CDATA[LeetCode-150-逆波兰表达式求值1. 题目：逆波兰表达式求值 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2： 123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例 3： 12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 2. 解题：主要使用Stack来存数字，遇到运算符时，则将栈顶的两个元素弹出，进行相应的运算。 注意：要注意两个数字的顺序，尤其是减法和除法。 使用一个HashMap来存放运算符，便于判断当前字符串是数字还是运算符。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;String, Character&gt; map = new HashMap&lt;&gt;(); map.put("+",'+'); map.put("-",'-'); map.put("/",'/'); map.put("*",'*'); for (int i = 0; i &lt; tokens.length; i++) &#123; if (!map.containsKey(tokens[i])) &#123; stack.push(Integer.valueOf(tokens[i])); continue; &#125; int num2 = stack.pop(); int num1 = stack.pop(); switch(tokens[i])&#123; case "+" : &#123; stack.push(num1 + num2); break; &#125; case "-" : &#123; stack.push(num1 - num2); break; &#125; case "*" : &#123; stack.push(num1 * num2); break; &#125; case "/" : &#123; stack.push(num1 / num2); break; &#125; &#125; /*if (tokens[i].equals("+")) &#123; stack.push(num1 + num2); &#125; else if (tokens[i].equals("-")) &#123; stack.push(num1 - num2); &#125; else if (tokens[i].equals("*")) &#123; stack.push(num1 * num2); &#125; else &#123; stack.push(num1 / num2); &#125;*/ &#125; return stack.pop(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>逆波兰表达式</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-371-两整数之和]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode-371%2F</url>
    <content type="text"><![CDATA[LeetCode-371-两整数之和1. 题目： 两整数之和 不使用运算符 + 和 - ，计算两整数 a 、b 之和。 示例 1: 12输入: a = 1, b = 2输出: 3 示例 2: 12输入: a = -2, b = 3输出: 1 2. 解题：使用二进制加法，也就是位运算。二进制加法有四种组合：1 + 1 = 10, 1 + 0 =1, 0 + 1 = 1, 0 + 0 = 0，我们发现只有一种情况是需要进位的，而且是都为1时。 我们使用&amp;运算来找出发生进位的位，并且将结果左移一位就可以得到进位carry。 我们使用^异或运算来找出不发生进位保留下的位sum。 将sum和carry“相加”。 我们会发现依然可能会出现“进位现象”，因此递归调用getSum()，直到carry = 0时返回sum。 代码：12345678910class Solution &#123; public int getSum(int a, int b) &#123; if (b == 0) &#123; return a; &#125; int carry = (a &amp; b) &lt;&lt; 1; int sum = a ^ b; return getSum(sum, carry); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>和运算</tag>
        <tag>二进制位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-166-分数到小数]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode-166%2F</url>
    <content type="text"><![CDATA[LeetCode-166-分数到小数1. 题目：分数到小数 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1: 12输入: numerator = 1, denominator = 2输出: &quot;0.5&quot; 示例 2: 12输入: numerator = 2, denominator = 1输出: &quot;2&quot; 示例 3: 12输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot; 2. 解题：吐槽一句，这个题真是太多“坑”。 首先说一下整体思想，分成三部分处理：符号＋整数部分＋小数部分。 符号：让两数相乘与0比较。 ​ 注意：int类型的范围为，因为Interger.MIN_VALUE * -1的结果会溢出，所以先转换成long类型。 整数部分：取两数的绝对值，进行整数的除法运算。这时判断余数是否为0，若为0则说明只有整数部分，否则，有小数部分。 小数部分：计算小数时，看作整数除法运算，余数每次乘十，向前进一位。 计算小数部分有３种情况： １）不是循环小数，则退出条件为余数为0 ２）纯循环小数，则小数部分全是循环体构成，只需找到循环体，加括号 ３）混循环小数，则小数部分是由不循环部分与第一个循环节连成的数字组成的数，需要找到其分界线 对于解决循环问题，我们使用一个HashMap&lt;Long, Integer&gt;来存每一次的余数，如果出现相同的余数，则说明出现循环；long是余数，Integet是字符串中的索引。 我们需要两个变量int index, int cycleIndex，分别用来存小数部分每位的索引，以及出现循环的索引。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public String fractionToDecimal(int numerator, int denominator) &#123; if (denominator == 0) return null; if (numerator == 0) return "0"; //符号 String flag = ""; //整数部分 String integer; //小数部分 StringBuilder dec = new StringBuilder(); //索引 int index = 0; //循环索引 int cycleIndex = -1; /** * 使用map存余数，如果余数存在则说明出现循环 * Long: 余数 * Integer: 余数的索引 */ Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); //注意int类型的溢出,Integer.MIN_VALUE / -1 long denominatorL = (long)denominator; long numeratorL = (long)numerator; //正负号 if (numeratorL * denominatorL &lt; 0) &#123; flag = "-"; &#125; //取绝对值 denominatorL = (long)Math.abs(denominatorL); numeratorL = (long)Math.abs(numeratorL); //整数部分 integer = String.valueOf(numeratorL / denominatorL); //取余数 numeratorL %= denominatorL; //只有整数 if (numeratorL == 0) &#123; return flag + integer; &#125; /** * 计算小数部分时，将其看做整数除法，每次将分母向前移一位 * 计算小数部分有３种情况： * １）不是循环小数，则退出条件为余数为０ * ２）纯循环小数，则小数部分全是循环体构成，只需找到循环体，加括号 * ３）混循环小数，则小数部分是由不循环部分与第一个循环节连成的数字组成的数，需要找到其分界线 */ map.put(numeratorL, index++); while (numeratorL != 0 &amp;&amp; cycleIndex == -1) &#123; numeratorL *= 10; dec.append(numeratorL/denominatorL); numeratorL %= denominatorL; if (map.containsKey(numeratorL)) &#123; cycleIndex = map.get(numeratorL); break; &#125; map.put(numeratorL, index++); &#125; //不是循环小数 if (cycleIndex == -1) &#123; return flag + integer + "." + dec.toString(); &#125; else &#123; return flag + integer + "." + dec.toString().substring(0, cycleIndex) + "(" + dec.toString().substring(cycleIndex) + ")"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-029-两数相除]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-029%2F</url>
    <content type="text"><![CDATA[LeetCode-029-两数相除1. 题目：两数相除 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 12输入: dividend = 10, divisor = 3输出: 3 示例 2: 12输入: dividend = 7, divisor = -3输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 2. 解题：首先不能使用乘法、除法和mod运算，我们想到可以使用减法来实现除法，但是我们会发现减法的效率很低。 除了这些操作，我们知道，位运算也可以表示乘法和除法，只是乘除的都是２的幂。 通过除法公式：dividend / (2^n) = divisor + 余数; 我们知道了：dividend / (2^n) &gt;= divisor时，余数：dividend - divisor*(2^n), 此时相当于dividend / divisor = 2^n. 则商就是满足情况的所有2^n的和。 注意： 对于正负问题，我们在处理之前，将正负号提取出来，使用它们的绝对值进行计算，最后的结果再加上正负号。 对于int类型范围问题（实际上就是Integer.MIN_VALUE的绝对值），我们使用long类型。 要注意除法溢出问题（实际上就是Integer.MIN_VALUE / -1）. 代码：12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int divide(int dividend, int divisor) &#123; int res = 0; // 被除数为0 if (dividend == 0) return res; // 除法溢出问题 if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) return Integer.MAX_VALUE; // 被除数的符号 int sign1 = 1; // 除数的符号 int sign2 = 1; // 防止int类型溢出 long dividendL = dividend; long divisorL = divisor; // 对被除数绝对值处理 if (dividendL &lt; 0) &#123; sign1 = -1; dividendL = sign1 * dividendL; &#125; // 对除数绝对值处理 if (divisorL &lt; 0) &#123; sign2 = -1; divisorL = divisorL * sign2; &#125; // 进行除法运算 for (int i = 31; i &gt;= 0; i--) &#123; // 找合适的2^n if (dividendL &gt;&gt; i &gt;= divisorL) &#123; // 结果加上2^n res += (1 &lt;&lt; i); // 当前除法的商 dividendL - divisorL * (2^n) dividendL -= (divisorL &lt;&lt; i); &#125; &#125; // 结果加上符号 return sign1*sign2*res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
        <tag>除法问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-5016-删除最外层的括号]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-5016%2F</url>
    <content type="text"><![CDATA[LeetCode-5016-删除最外层的括号1. 解题：删除最外层的括号 有效括号字符串为空 (&quot;&quot;)、&quot;(&quot; + A + &quot;)&quot; 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 &quot;(()(()))&quot; 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1： 12345输入：&quot;(()())(())&quot;输出：&quot;()()()&quot;解释：输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;。 示例 2： 12345输入：&quot;(()())(())(()(()))&quot;输出：&quot;()()()()(())&quot;解释：输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;，删除每隔部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;。 示例 3： 12345输入：&quot;()()&quot;输出：&quot;&quot;解释：输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;，删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; = &quot;&quot;。 提示： S.length &lt;= 10000 S[i] 为 &quot;(&quot; 或 &quot;)&quot; S 是一个有效括号字符串 2. 解题：这个题实际上是括号匹配问题的变形。 首先我们知道S是一个有效括号字符串。但我们用括号匹配问题来处理： 用Stack在存放(，用StringBuilder来存放解集。 当遇到(时，压栈并放入StringBuilder，但是如果栈为空，说明是外（，不放入StringBuilder。 当遇到)时，弹栈并放入StringBuilder，但是如果栈大小为１，说明是外），不放入StringBuilder。 代码：12345678910111213141516171819202122232425class Solution &#123; public String removeOuterParentheses(String S) &#123; if (S == null || S.length() &lt;2) return null; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); StringBuilder strB = new StringBuilder(); for (int i = 0; i &lt; S.length(); i++) &#123; if (S.charAt(i) == '(') &#123; // 如果栈为空，则说明要放 外( 则不放入解集 if (!stack.empty()) &#123; strB.append('('); &#125; stack.push('('); &#125; if (S.charAt(i) == ')') &#123; // 如果栈为1，则说明要放 外) 则不放入解集 if (stack.size() != 1) &#123; strB.append(')'); &#125; stack.pop(); &#125; &#125; return strB.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>括号问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-069-x的平方根]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-069%2F</url>
    <content type="text"><![CDATA[LeetCode-069-x的平方根1. 题目：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 2. 解题使用牛顿迭代法。 参考文章：如何通俗易懂地讲解牛顿迭代法？ 使用牛顿迭代会比二分法进行更少的计算次数。 首先我们设函数:$$f(x) = x^2 - a(a是要求平方根的常数)$$ 则求导为：$$f’(x) = 2x$$ 根据$$f(x_n)+f’(x_n)(x - x_n) = 0$$ 得到迭代公式：$$x_{n+1} = x_n - f(x_n)/f’(x_n)$$当满足条件x^2 &lt;= a &amp;&amp; (x+1)^2 &gt; a时得到结果，需要注意x^2会导致int溢出问题，我们使用long来避免这个问题。 代码：1234567891011121314class Solution &#123; public int mySqrt(int x) &#123; if (x &lt; 0) return -1; if (x &lt;= 1) return x; // 猜想数 long res = x/2; while (!(res * res &lt;= x &amp;&amp; (res + 1) * (res + 1) &gt; x)) &#123; res = (res + x/res) / 2; &#125; return (int)res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
        <tag>平方根</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-050-Pow(x, n)]]></title>
    <url>%2F2019%2F04%2F06%2FLeetCode-050%2F</url>
    <content type="text"><![CDATA[LeetCode-050-Pow(x, n)1. 题目：Pow(x, n) 实现pow(x, n)，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 2. 解题：我们使用分治方法。我们知道如果是偶数次幂，例如x^8，我们通过x^4, x^2, x^1来求出，这样减少了运算。如果是奇数次幂，奇数减一就是偶数，最后再补一个x就可以。 代码：12345678910111213141516171819202122class Solution &#123; public double myPow(double x, int n) &#123; if (n &lt; 0) &#123; return 1.0 / pow(x, -n); &#125; else &#123; return pow(x, -n); &#125; &#125; private double pow(double x, int n) &#123; if (n == 0) return 1; double res; double temp = pow(x, n/2); if (n % 2 == 0) &#123; res = temp * temp; &#125; else &#123; res = temp * temp * x; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-171-Excel表列序号]]></title>
    <url>%2F2019%2F04%2F06%2FLeetCode-171%2F</url>
    <content type="text"><![CDATA[LeetCode-171-Excel表列序号1. 题目：Excel表列序号 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1: 12输入: &quot;A&quot;输出: 1 示例 2: 12输入: &quot;AB&quot;输出: 28 示例 3: 12输入: &quot;ZY&quot;输出: 701 2. 解题：这个题类似与“26进制”，每26进一位。有两种思路，首先我们看从高位到低位。 以次取除字符串中的字符，判断当前字符串在第几位。 使用pow(26.0, 位数)求出其当前位置的值，例如十进制中，百位-10^2，个位-10^1。 依次相加就可以求解。 代码：1234567891011121314class Solution &#123; public int titleToNumber(String s) &#123; if (s == null || s.length() == 0) return 0; int res = 0; int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; double num = Math.pow(26.0, (double)len - i - 1); res += (s.charAt(i) - 'A' + 1) * num; &#125; return (int)res; &#125;&#125; 3. 其他解法：思想不变，但是从低位向高位出发，不使用pow()函数，用一个count来代替。 代码：12345678910111213141516class Solution &#123; public int titleToNumber(String s) &#123; if (s == null || s.length() == 0) return 0; int res = 0; int count = 1; int len = s.length(); char[] ch = s.toCharArray(); for (int i = len-1; i &gt;= 0; i--) &#123; count *= (i == len -1) ? count : 26; res += (ch[i] - 'A' + 1) * count; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
        <tag>进制问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-094-中序遍历二叉树]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-094%2F</url>
    <content type="text"><![CDATA[LeetCode-094-中序遍历二叉树1. 题目：给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 2. 解题： 中序遍历：中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。 使用递归算法，对每一个节点，都先遍历其左子树，再遍历其本身，最后遍历其右子树。 注意：解集需要使用一个集合存储。 代码：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; inoerderFun(list, root); return list; &#125; private void inoerderFun(List&lt;Integer&gt; list, TreeNode root) &#123; if (root == null) return; inoerderFun(list, root.left); list.add(root.val); inoerderFun(list, root.right); &#125;&#125; 3. 进阶：对于二叉树的遍历，我们也可以使用非递归的形式。 非递归遍历，我们需要使用Stack。 从根节点出发，不为空时，将根节点入栈，然后遍历左子树； 当根节点为空时，弹栈（相当与访问根节点），遍历弹出节点的右子树； 若根节点为空，此时栈为空，则遍历完成。 代码：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode node = root; while (node != null || !stack.isEmpty()) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125; else &#123; list.add(stack.peek().val); node = stack.pop().right; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-172-阶乘后的零]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-172%2F</url>
    <content type="text"><![CDATA[LeetCode-172-阶乘后的零1. 题目：阶乘后的零 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 2. 解题：我们需要找到阶乘末尾有多少个0，直接求出阶乘的结果，再数0的个数是无法实现的，因为当n比较大时，阶乘后的结果会溢出。 核心就是，乘法中出现0的情况。 12345673! = 6 没有05! = 5*4*3*2*1 = 120 有1个0，并且是因为2*5才会得到010! : 2*4*6*8*5*10 = 2*5*(2*5)*4*6*8 -&gt; 2个0因此，找0就成了找2,5以及其倍数，2的个数要多于5，因此就是来找5的个数。但是还要考虑：31! : 5*(2*5)*(3*5)*(4*5)*(5*5)*(6*5) -&gt;有7个5 -&gt;有7个0所以我们需要找(5^n)的个数，比如5,25,125... 代码：123456789class Solution &#123; public int trailingZeroes(int n) &#123; int countZero = 0; while(n &gt; 0) &#123; countZero += (n /= 5); &#125; return countZero; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
        <tag>阶乘问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-202-快乐数]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode-202%2F</url>
    <content type="text"><![CDATA[LeetCode-202-快乐数1. 题目：快乐数 编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 1234567输入: 19输出: true解释: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 2. 解题：主要是跟着题意出发，判断n是否是快乐数。 需要注意几点： 主要部分就是对n进行/10和%10运算，然后对每一位平方，求和。 但是对于可能出现无限循环的情况，才用set来解决，将出现的所有n都放进set，判断n是否在Set中出现过，若出现过则说明出现循环。 代码：12345678910111213141516171819class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while (!set.contains(n)) &#123; set.add(n); int tmp = 0; if (n != 1) &#123; while (n &gt; 0) &#123; tmp += (n % 10) * (n % 10); n /= 10; &#125; &#125; else &#123; return true; &#125; n = tmp; &#125; return false; &#125;&#125; 3. 优化：​ 针对于出现循环的情况，最后只会进入一个循环4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4，因此只需要判断n是否等于4。 代码：123456789101112131415class Solution &#123; public boolean isHappy(int n) &#123; int tmp = 0; while (n != 1) &#123; while (n &gt; 0) &#123; tmp += (n % 10) * (n % 10); n /= 10; &#125; n = tmp; tmp = 0; if (n == 4) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
        <tag>快乐数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-297-二叉树的序列化与反序列化]]></title>
    <url>%2F2019%2F04%2F03%2FLeetCode-297%2F</url>
    <content type="text"><![CDATA[LeetCode-297-二叉树的序列化与反序列化1. 题目：二叉树的序列化与反序列化 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 2. 解题：简单来说，序列化就是将TreeNode转化成String，反序列化就是将String转化成TreeNode。 通过题目我们可以知道，序列化是将二叉树通过层序遍历的顺序得到的，同时空树节点用null来表示。 反序列化，需要我们通过String来将每一个节点找出来，这时候就要分割String，然后得到每一个树节点。 对于层序遍历，我们需要用到Queue。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if (root == null) return null; StringBuilder result = new StringBuilder(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if (node != null) &#123; result.append(node.val + ","); queue.offer(node.left); queue.offer(node.right); &#125; else &#123; result.append("null,"); &#125; &#125; return result.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data == null || data.length() == 0) return null; String[] strs = data.split(","); // 判断根节点是否为空 if (strs[0].equals("null")) return null; int index = 1; TreeNode root = new TreeNode(Integer.valueOf(strs[0])); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // 不是null，给左侧 if (!strs[index].equals("null")) &#123; node.left = new TreeNode(Integer.valueOf(strs[index])); queue.offer(node.left); &#125; index++; // 不是null，给右侧 if (!strs[index].equals("null")) &#123; node.right = new TreeNode(Integer.valueOf(strs[index])); queue.offer(node.right); &#125; index++; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>层序遍历</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析HashMap(三)——红黑树（TreeNode）]]></title>
    <url>%2F2019%2F04%2F02%2FHashMap-3%2F</url>
    <content type="text"><![CDATA[解析HashMap(三)——红黑树（TreeNode）一、概述​ 由于在JDK1.8中，在HashMap中为了提高性能新加了红黑树，在putVal()和remove()方法中都使用到了红黑树。我们来介绍HashMap中几个关键方法。 二、源码分析1. TreeNode​ 首先我们要知道，所有有关红黑树的操作都是在HashMap的内部类TreeNode中。 ​ TreeNode&lt;K, V&gt;也是继承Node&lt;K, V&gt;. 1static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;...&#125; 2. 属性：12345678910111213/* 红黑树中的父节点 */TreeNode&lt;K,V&gt; parent;/* 红黑树中的左子树 */TreeNode&lt;K,V&gt; left;/* 红黑树中的右子树 */TreeNode&lt;K,V&gt; right;/* bucket既保持了链表的结构用(next,prev)也保持了红黑树的结构(left,right,parent) * 遍历时候红黑树可以当作链表处理，有next * 删除之后需要断开链接 */TreeNode&lt;K,V&gt; prev;/* 是否是红节点 */boolean red; 3. 构造函数：123TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next);&#125; 4. 树化treeifyBin(Node&lt;K,V&gt;[] tab, int hash)​ 树化的条件：链表中的个数 ≥ TREEIFY_THRESHOLD，但是并不是满足这个条件一定树化，当满足这个条件时，进入treeifyBin()方法，此时会判断两个条件： tab为null tab的length也就是capacity的大小比MIN_TREEIFY_CAPACITY=64小 ​ 因为这个时候认为扩容的效果比树化要好。 ​ 树化的三步： Node节点变成TreeNode节点 链表变成双向链表 双向链表变成红黑树 12345678910111213141516171819202122232425262728293031323334/* 将hash对应的bucket链表红黑树树化 */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // 判断是树化还是扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); // 树化 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; // 如果当前bucket不为null // hd 头指针 tl 尾指针 TreeNode&lt;K,V&gt; hd = null, tl = null; /** * 循环遍历整个链表 * 1. 先把Node节点转换成TreeNode节点 * 2. 红黑树的所有节点按原来的顺序利用指针(prev和next)形成了一个双向链表 * 这也是多次遍历链表的时候顺序也不会变化的原因 */ do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); /** * 将TreeNode形成的双向链表转化成红黑树 */ if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)1234// 将Node节点转化成TreeNode节点TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);&#125; treeify(Node&lt;K,V&gt;[] tab)​ 该方法将TreeNode形成的双向链表转化成红黑树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 调用该方法的时候this就已经是一个TreeNode了 * 而且整个链表的节点类型已经从Node转换成TreeNode,但是顺序没有变化 */final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; // 遍历链表 x是当前节点 for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; // 插入的是第一个元素，并给root赋值 if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; // 从链表拿出的当前节点的 键 K k = x.key; // 从链表拿出的当前节点的 哈希值 int h = x.hash; Class&lt;?&gt; kc = null; // 插入到红黑树中的位置,逻辑跟putTreeVal类似 for (TreeNode&lt;K,V&gt; p = root;;) &#123; // dir 通过比较hash得到，ph从红黑树拿出的当前节点哈希值 int dir, ph; // 从红黑树拿出的当前节点哈希值 K pk = p.key; // 链表节点哈希值&lt;红黑树节点，去左侧 if ((ph = p.hash) &gt; h) dir = -1; // 链表节点哈希值&gt;红黑树节点，去右侧 else if (ph &lt; h) dir = 1; // 哈希值相同时，通过key值比较， else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) //如果没有key比较器,调用tieBreakOrder()强制比较 dir = tieBreakOrder(k, pk); // xp 代表 红黑树节点 TreeNode&lt;K,V&gt; xp = p; // dir ≤ 0去左侧，否则去右侧 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; // 找到叶子节点，链表节点作为其儿子 x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; // 平衡红黑树 root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; // 把root节点移到链表头 moveRootToFront(tab, root);&#125; tieBreakOrder(Object a, Object b)​ 强行比较a,b的大小。 12345678910/** * a或者b为null或者如果a和b同属一个类就调用系统的identityHashCode */static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName().compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d;&#125; 5. 插入putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v)​ 在HashMap的putVal()方法中，我们使用到了putTreeVal()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; // 是否找到的标志 boolean searched = false; // 找到红黑树的根 TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; /** * for 循环从根节点去寻找到该节点应该插入的位置,TreeNode之间的比较是通过该节点的hash值 * 利用红黑树具有二叉搜索树的性质 */ for (TreeNode&lt;K,V&gt; p = root;;) &#123; /* * dir用来判断选择左子树还是右子树,dir = -1选择左侧，dir = 1选择右侧 * ph用来存放树中当前节点 */ int dir, ph; // pk用来存放树中当前节点的键 K pk; // 如果 插入节点 hash值小于 树的当前节点 的hash值,往左侧 if ((ph = p.hash) &gt; h) dir = -1; // 如果 插入节点 hash值大于 树的当前节点 的hash值,往右侧 else if (ph &lt; h) dir = 1; // 节点已经存在，直接返回该节点 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; /** * hash值相等但是key值没有匹配上会进行以下操作 * 总的来说就是先根据hash比较，hash相同根据key比较 * 1. 调用comparableClassFor先看该k是否已经实现compareable&lt;k.class&gt;接口 * 2. 如果实现了Compareable&lt;k.class&gt;接口,就进行compareComparables方法看看是否可以比较出结果 * 3. 如果还是没有比较出结果,就去左右子树中搜索有没有该节点(注意只搜索一次) * 4. 如果左右子树中也没有该节点,说明必须要插入该节点到此红黑树中,所以就调用tieBreakOrder强行分出大小 */ else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; /* * 在左右子树查找该节点，如果有则返回该节点 * find()方法实际上就是二叉树的查找 */ if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; // 当前树中没有该节点,通过key分大小，决定插入位置 dir = tieBreakOrder(k, pk); &#125; /** * 到这里说明红黑树中没有该节点 * 观察当前节点是进入左侧，还是进入右侧，还是插入 * 如果是插入的时候会进入if block 中的内容 */ TreeNode&lt;K,V&gt; xp = p; // 直到找到叶子节点为止 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; // xpn是xp的next Node&lt;K,V&gt; xpn = xp.next; //Node变为TreeNode TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); //插入到红黑树中 if (dir &lt;= 0) xp.left = x; else xp.right = x; //插入到链表中 xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; /** * 调整红黑树返回新的节点值 * 把返回新的节点值移到链表的头 */ moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125;&#125; comparableClassFor(Object x)123456789101112131415161718192021222324252627282930313233343536373839/** * @param x 对象x * @return 如果x所属的类实现了Comparable&lt;T&gt;接口,并且T是x类,返回该类 * 比如: class Person implements Comparable&lt;Person&gt;; * 如果class Person 或者 class Person implements Comparable 或者 class Person implements * Comparable&lt;String&gt;都会返回null; */static Class&lt;?&gt; comparableClassFor(Object x) &#123; // 判断x所属的类实现了Comparable&lt;T&gt;接口 if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; // 如果是String类直接返回了 if ((c = x.getClass()) == String.class) return c; /** * getGenericInterfaces(): * Returns the Types representing the interfaces directly implemented * by the class or interface represented by this object. * 就是返回c类实现的所有接口 */ if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; /** * Comparable&lt;Person&gt;如果此接口含有泛型并且原型class是Compable类, * getActualTypeArguments()返回这个类里面所有的泛型,返回一个数组, * as.length == 1 &amp;&amp; as[0] == c 是为了保证Comparable&lt;T&gt;里面只有一个泛型并且就是 * 传入的类c. */ if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null;&#125; Person类的定义 调用 返回 class Person comparableClassFor(new Person(&quot;Tom&quot;, 12)) null class Person implements Comparable comparableClassFor(new Person(&quot;Tom&quot;, 12)) null class Person implements Comparable&lt;String&gt; comparableClassFor(new Person(&quot;Tom&quot;, 12)) null class Person implements Comparable&lt;Person&gt; comparableClassFor(new Person(&quot;Tom&quot;, 12)) Person compareComparables()1234567/** * 如果类不同就返回0 否则就返回调用compareTo比较后的结果 */@SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));&#125; 6. 删除​ 在HsahMap的removeNode方法中，如果我们删除的是红黑树上的节点，我们调用了红黑树的两个方法treeNode.getTreeNode(hash, key)和treeNode.removeTreeNode(this, tab, movable).我们现在就来分析这两个方法。 getTreeNode(int h, Object k)​ 这个方法比较简单，先找到当前节点的root根节点，然后调用根节点的find()方法，直到找到目标节点。 123final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null);&#125; removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable)​ 删除树节点的大致过程： 先在链表中删除 判断是否需要链表化 最后再进行红黑树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; /* 如果tab等于null或者tab.length长度为0 直接返回 */ if (tab == null || (n = tab.length) == 0) return; // 求在数组中的索引 int index = (n - 1) &amp; hash; // first是链表中的头节点 TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; // succ是被删除节点的下一个节点，pred是被删除节点的上一个节点 TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; /* 在链表中删除 */ // 链表的第一个节点就是要被删除的节点 if (pred == null) // 让第二节点作为头结点 first = succ; tab[index] = first; // 被删除节点不是头结点 else // 其上一个节点和下一个节点直接相连 pred.next = succ; //双向连接 if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); /** * too small 直接把红黑树转成链表 * 该判断作为链表化的阀值 */ if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; /** * 接下来就是红黑树的节点删除 * p 被删除的节点，pl被删除节点的左儿子，pr被删除节点的右儿子 * replacement被删除节点的后继节点 */ TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; // p不是叶子节点 if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; // 找到其后继结点 while ((sl = s.left) != null) s = sl; // 交换颜色 boolean c = s.red; s.red = p.red; p.red = c; TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; // p是s的直接父节点 if (s == pr) &#123; // 交换位置 p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r);&#125; 7. 链表化：untreeify(HashMap&lt;K,V&gt; map)​ 我们在调用rmoveTreeNode()和扩容时调用split()时有可能使用该方法。 123456789101112131415161718/** * 红黑树链表化 */final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; //循环，将红黑树转成链表 for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; //将树节点转化成链表节点 Node&lt;K,V&gt; p = map.replacementNode(q, null); //维护顺序 if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd;&#125; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)​ 构造一个Node节点。 123Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next);&#125; 8. 扩容时转移节点split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit)我们在扩容时，对于链表的情况是将链表分成两个链表，而对于树也类似；我们将树从给定的结点分裂成低位和高位的两棵树，若新树结点太少则转为线性链表。只有`resize`时会调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * @param map the map * @param tab 数组 * @param index 需要分裂的表下标位置，数组下标 * @param bit 分裂时分到高位和低位的依据参数，实际使用时输入的是扩展之前旧数组的大小 */final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; //重新链接到lo和hi链表，保留顺序 //低位头尾指针 TreeNode&lt;K,V&gt; loHead = null, loTail = null; //高位头尾指针 TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; //低位和高位的结点个数统计 int lc = 0, hc = 0; //e从this开始遍历直到next为null，一般是链表的头结点 for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; //这段决定了该结点被分到低位还是高位，依据算式是e.hash &amp; bit，由于bit是oldCap，所以一定是2的指数次幂，所以bit一定只有一个高位是1其余全是0 //这个算式实际是判断e.hash新多出来的有效位是0还是1，若是0则分去低位树，是1则分去高位树 if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; //分裂后的低位树结点太少转为线性链表 if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; //若高位树为null则代表整棵树全保留在了低位，树没有变化所以不用进行后面的treeify if (hiHead != null) loHead.treeify(tab); &#125; &#125; //这段与上面对于低位部分的分析相对应 if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; //高位所处的位置为原本位置+旧数组的大小即bit tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>红黑树</tag>
        <tag>JDK1.8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析HashMap（二）]]></title>
    <url>%2F2019%2F04%2F02%2FHashMap-2%2F</url>
    <content type="text"><![CDATA[解析HashMap（二）一、概述​ JDK1.8中对HashMap做了很大的优化，其中最重要的优化就是其底层实现将原来的“数组＋链表”改为“数组＋链表＋红黑树”。下面通过源码来分析HashMap。 二、源码分析：1. 常量：123456789101112/* 默认的数组的长度 或者说 默认是buckets/bins的长度 16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; /* 最大长度 2的30次方 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /* 默认的加载因子 用于计算阈值(threshold) */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /* 用于红黑树树化的节点个数阈值 */ static final int TREEIFY_THRESHOLD = 8; /* 用于解除红黑树树化(将红黑树转换为链表)的节点个数阈值 */ static final int UNTREEIFY_THRESHOLD = 6; /* 用于红黑树树化时要求数组的最小长度 */ static final int MIN_TREEIFY_CAPACITY = 64; 2. 属性：​ 有些属性设置为transient是与序列化有关。 transient 关键字 Java序列化会把某一个类存储以文件形式存储在物理空间，但是以文件形式存储某些信息时，容易涉及到安全问题，因为数据位于Java运行环境之外， 不在Java安全机制的控制之中。对于这些需要保密的字段，不应保存在永久介质中 ，或者不应简单地不加处理地保存下来 ，为了保证安全性。 应该在这些字段前加上transient关键字。它的意思是临时的，即不会随类一起序列化到本地，所以当还原后，这个关键字定义的变量也就不再存在。 123456789101112/* 用于存节点的数组(节点会hash到table中的某一个index) */ transient Node&lt;K, V&gt;[] table; /* 用于存HashMap中的所有节点 */ transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet; /* 节点的总个数 */ transient int size; /* 修改的次数 */ transient int modCount; /* 决定是否 扩容 的阀值 */ int threshold; /* 加载因子 用于计算阈值(threshold) */ final float loadFactor; 3. 内部类Node&lt;K, V&gt;​ 继承了Map.Entry&lt;K, V&gt;类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; final int hash; // 节点的hash值 final K key; // 节点的键 V value; // 节点的值 Node&lt;K, V&gt; next; // 指向下一个节点的指针 /* 构造函数 */ Node (int hash, K key, V value, Node&lt;K, V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; /* 重写getKey()方法 */ @Override public K getKey() &#123; return key; &#125; /* 重写getValue()方法 */ @Override public V getValue() &#123; return value; &#125; /* 重写setValue()方法 替换原来的值，返回旧值*/ @Override public V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; /* 比较当前的节点与对象o是否属于同一个对象 final方法表示子类不能重写 */ public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; //判断类型 Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 4. 构造函数：​ 我发现构造函数中，并没有initialCapacity这个属性，仅仅使用其来判断容量异常，通过这个属性求threshold，之后没有使用它，数组的长度没有声明，所以如何给数组初始化多大长度呢? ​ 是通过resize()来初始化数组长度的。 123456789101112131415161718192021222324/* 传入容量和负载因子两个参数 */public HashMap(int initialCapacity, float loadFactor) &#123; //检查传入的容量大小是否有异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); //如果大于最大容量,则直接赋值为最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //检查loadFactor是否有异常，NaN指”不是一个数“ if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; //赋值loadFactor操作 this.threshold = tableSizeFor(initialCapacity); //根据初始容量计算出阀值 &#125; /* 传入容量一个参数 */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); //采用默认加载因子调用第一个构造函数 &#125; /* 不传参数 */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // 其余的属性都采用默认值 &#125; tableSizeFor(int cap)​ 这个方法和JDK1.7中的roundUpToPowerOf2()中使用的Integer.highestOneBit(int i)方法相似。 ​ 返回值一定是2的幂，该方法是返回大于等于cap的最小2的幂。 123456789101112131415static final int tableSizeFor(int cap) &#123; int n = cap - 1; //为了处理本身就为2的幂 //step 1 n |= n &gt;&gt;&gt; 1; //step 2 n |= n &gt;&gt;&gt; 2; //step 3 n |= n &gt;&gt;&gt; 4; //step 4 n |= n &gt;&gt;&gt; 8; //step 5 n |= n &gt;&gt;&gt; 16; //现在得到了从最高位开始都为1 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 1234567891011121314151617181920212223此方法使用 移位 和 或运算 来实现的首先我们需要知道1 | X = 1, 0 | X = Xcap ≠ 2的幂我们假设一个整数n的二进制为：１XXX XXXX (X表示可１可０)step 1 : n = 1XXX XXXX | 01XX XXXX = 11XX XXXXstep 2 : n = 11XX XXXX | 0011 XXXX = 1111 XXXXstep 3 : n = 1111 XXXX | 0000 1111 = 1111 1111step 4 : n = 1111 1111 | 0000 0000 = 1111 1111step 5 : n = 1111 1111 | 0000 0000 = 1111 1111step 6 : 1111 1111 + 1 = 1 0000 0000我们知道这五步是将n从最高位开始全部置为１第６步是得到大于等于n的最小2的幂我们再来看看cap = 2的幂cap = 1000 n = 0111step 1 : n = 0111 | 0011 = 0111step 2 : n = 0111 | 0001 = 0111step 3 : n = 0111 | 0000 = 0111step 4 : n = 0111 | 0000 = 0111step 5 : n = 0111 | 0000 = 0111step 6 : 0111 + 1 = 1000 5. 插入put(K key, V value)​ 我们发现put方法很简单，其核心方法是hash()和putVal()。 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; hash(Object key)​ 该方法是返回key的hash值。主要是通过将key的hashcode的高16位和低16位进行异或处理，这样做的目的是，使得高位也参加hash的运算，使得哈希尽可能的均匀分布。 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)​ hash：当前key的hash值； ​ onlyIfAbsent：为true时不改变原有的值，为false用value替代旧值； ​ evict：在HashMap的子类LinkedHashMap中会有用。 ​ 数组的初始化在该方法中。 ​ 使用hash &amp; (length -1)来计算index，相当于取模运算，但是速度更快。 这是数组长度为２的幂的第一个用处，方便使用位运算来求index ​ 该方法，若该节点不存在，则将该节点插入，返回为null;否则，旧值替换新值，返回旧值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; /* 如果tab还没有创建数组的话,则需要去resize方法中创建数组 */ if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /** * 1. 首先根据hash值计算出该节点属于哪个bucket/bin,也就是index * i = (n - 1) &amp; hash 其实就等于 hash % n * 2. 如果此时的bucket是空,表明这个bucket还没有任何节点存入, * 因此生成新节点后直接放入到该bucket */ if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; /** * 当前位置不为空,所以这个节点应该放到这个bucket的后面 * 有三种情况(互斥条件,要么1要么2要么3出现) */ Node&lt;K, V&gt; e; // 如果这个节点已经存入过,就会拿出那个节点并且赋给e K k; /* * 情况1 * 此节点已经存在并且就在 bucket 的第一个位置,直接把 p 赋给 e */ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) /* * 情况2 * p是一个TreeNode节点,表明已经树化，因此要调用红黑树的插入或者调整等相关操作 */ e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); else &#123; /* * 情况3 * 不是当前位置也没有树化，则需要遍历链表 * 需要注意，如果是新增的节点，则链表中的数量就会增加，则时候要考虑是否会树化 */ // 遍历链表并且记录链表个数 for (int binCount = 0;; ++binCount) &#123; // 从链表的第二个开始,因为p在第一种情况已经比较过了 if ((e = p.next) == null) &#123; //说明之前没有该节点 p.next = newNode(hash, key, value, null); // 插入到链表尾 /* * 判断是否树化,需要用到TREEIFY_THRESHOLD * 这里的减一，是因为是从第二个节点开始计数的 */ if (binCount &gt;= TREEIFY_THRESHOLD - 1) //进行树化 treeifyBin(tab, hash); break; &#125; //表明链表中已经存在了这个节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //当前节点不是，遍历下一个 p = e; &#125; &#125; /* e不为null表明此节点已经存入过，所以这里没有modCount++ 返回旧值，如果新值替换旧值 */ if (e != null) &#123; V oldValue = e.value; /* onlyIfAbsent为true时不改变原有的值，为false用value替代旧值； 如果oldValue为null,那onlyIfAbsent就不起作用了 */ if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 用于子类LinkedHashMap的方法 return oldValue; &#125; &#125; /* 进行到这里,说明 e==null,则之前没有此节点(或者说key也行)存入过 */ ++modCount; // modCount++ if (++size &gt; threshold) // 先增加size的个数 判断是否需要扩容 resize(); afterNodeInsertion(evict); // 用于子类LinkedHashMap的方法 return null; &#125; 6. 扩容​ 扩容的条件：size &gt; threshold，而初始值是在构造函数中通过this.threshold = tableSizeFor(initialCapacity);得到的。 ​ 扩容有两种情况： ​ a) 进行数组的初始化，此时oldCap = 0。还能根据构造函数的不同分为两种情况： ​ 1) 使用带参的构造函数，有threshold，通过tableSizeFor(initialCapacity)得到。 ​ 2) 使用不带参的构造函数，没有threshold，通过默认的容量大小*默认负载因子得到。 ​ 当数组初始化完成后直接返回。 ​ b) 数组被初始化过，数组被扩容为原来的两倍，此时oldCap &gt; 0。数组扩容后，需要将原数组的元素移到新的数组上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127final Node&lt;K,V&gt;[] resize() &#123; // oldTab 是 table Node&lt;K,V&gt;[] oldTab = table; // oldCap 是 以前table的length,如果以前是null就为0 int oldCap = (oldTab == null) ? 0 : oldTab.length; // oldThr 是 旧阀值 int oldThr = threshold; // 新容量 新阀值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; /** * 已经初始化过 */ //无法再进行扩容 直接把阀值设置为最大后返回 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //可以进行扩容，容量扩容两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 阀值变为原来的2倍 newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) /** * 第一次初始化 且 有阀值 * 有参的两个构造函数会进入这个分支 * 这个知道为什么没有initCapacity也可以给table初始化长度了 * 数组长度是通过“阀值”初始化 * newThr没有赋值 */ newCap = oldThr; else &#123; /** * 第一次初始化 且 没有阀值 * 无参构造函数会进入这个分支 */ newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新的阀值为0 则重新设置一下阀值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //设置一下阀值 threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //初始化新数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //设置一下新table table = newTab; /* * 扩容后，判断是否需要移元素 * oldTab = null :如果第一次初始化的时候就直接返回了 * olfTab ≠ null :需要把所有在oldTab上的元素转移到新的table中 */ if (oldTab != null) &#123; // 需要遍历每一个数组，还要遍历每个数组中的每一个节点 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; /* * 表明这个bucket里面有节点 * 分为三个情况，和put中的三种情况相对应 */ oldTab[j] = null; if (e.next == null) /* 情况一：只有一个节点 * 那直接rehash一下放到新的table中就可以了 */ newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) /* 情况二：如果是树节点，需要调用红黑树的方法 */ ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; /* 情况三：是链表 * 直接遍历链表。 * 我们知道数组扩容为原来的2倍， * 求index是的位运算从"hash &amp; (length - 1)"变成"hash &amp; (2*length - 1)" * "2*length-1"就是最高位多了1，此时只需要看k.hash的最高位是１还是０ * 最高位为０，新位置＝数组原来的位置 * 最高位为１，新位置＝数组原来的位置＋原数组的长度 * 这样就是将原链表分成两个链表 * 最后两个链表头放到table对应的bucket中 */ // 结果为0的链表-loHead Node&lt;K,V&gt; loHead = null, loTail = null; // 结果为1的链表-hiHead Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; // 最高位为0的情况 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // 最高位为1的情况 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; // rehash的结果没有改变 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; // rehash的结果就在原有的hash的结果上加上oldCap就可以了 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; ​ 扩容会伴随一次重新的hash分配，并且会遍历一遍原来哈希表中的所有元素，消耗大量资源，所以我们应该避免resize. 7. 获取​ 获取元素要比插入元素简单，我们知道哈希表的最大特点就是不需要遍历可以直接找到元素所在的“桶位”。 ​ 当我们找到元素的桶位时，也分３中情况：只有一个节点（或者第一个节点就是）；是树节点；是链表。 get(Object key)1234567/** * 通过key获取value */public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; getNode(int hash, Object key)12345678910111213141516171819202122232425262728/** * 通过hash找到元素的桶位 * 通过key判断元素是否存在 */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; // 数组容量 int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //如果Node链表的第一个元素相等 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //红黑树查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //链表查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; //找不到返回null return null;&#125; containsKey(Object key)123456/** * 判断是否包含指定key */public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; //返回node是否为null&#125; containsValue(Object value)12345678910111213141516171819/** * 判断是否包含指定value */public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; //按照单链表的方式进行遍历， //因为HashMap中 TreeNode 节点也存在next成员，可以用链表的方式进行遍历 for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false;&#125; 8. 删除​ 删除有两种方式： remove(Object key)根据key删除 remove(Object key, Object value) 根据key和value删除 ​ 需要注意：只有扩容操作，没有减少容量的操作。 remove(Object key, Object value)12345678910/** * 注意与remove(Object key)不同的两点: * 1. 要根据key,value同时符合才可以删除该节点 * 2. 返回值是true 表明正确删除 * 返回值是false 表明没有这个节点 */ @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; remove(Object key)123456789/** * 根据key来remove在HashMap中的节点 * 如果删除成功，返回该节点 * 如果删除失败，返回null */ public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /** * @param hash hash值 * @param key 键 * @param value 值 * @param matchValue 如果true表明必须key和value同时符合要求才可以删除,如果false的话只需要key符合就可以 * @param movable 用于红黑树中的操作 * @return 如果存在这个节点,会返回此节点，否则返回null */final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, index; /* * 分两步: * 1. 先寻找到节点,如果存在则放到node中 * 2. 如果存在删除该节点 */ // 第一步 查找节点 类似于getNode() if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K, V&gt; node = null, e; K k; V v; /** * 如果存在这个节点,会把节点赋值给node * 分三种情况: */ // 1. 就在hash值对应的bucket中是第一个元素 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 2. 在红黑树中 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); // 3. 在链表中 else &#123; do &#123; // 遍历链表查找，查找到后赋值给node if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; // 找到后退出循环，到达第二步 node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; /** * 第二步:删除操作 * 也分三种情况 * matchValue为false，后边是短路，针对只用key删除 */ if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 1. 树节点，调用红黑树的相关方法 if (node instanceof TreeNode) ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); // 2. 第一个节点，直接bucket节点设置为node.next else if (node == p) tab[index] = node.next; // 3. 在链表中删除node节点 else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); //留作子类LinkedHashMap中使用 return node; &#125; &#125; return null; &#125;]]></content>
      <categories>
        <category>Java</category>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>JDK1.8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-300-最长上升子序列]]></title>
    <url>%2F2019%2F04%2F02%2FLeetCode-300%2F</url>
    <content type="text"><![CDATA[LeetCode-300-最长上升子序列1. 题目：Longest Increasing Subsequence 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 2. 解题：我们要注意几点： 上升子序列是“严格上升”，是num[i] &lt; num[j]不能等于。 上升子序列不需要保证连续，只要满足大小即可。 我们使用动态规划，使用数组dp[i]来存放num[i]作为子序列最后一个元素的子序列最大个数。自底向上(从nums[0]到nums[len-1])，计算每一个元素的作为最后一个元素的最大上升子序列的长度。 我们知道公式为：满足j &lt; j &amp;&amp; nums[j] &lt; nums[i]时，dp[i] = max{1 + dp[j]}。 代码：12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return 1; int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], 1+dp[j]); &#125; &#125; Arrays.sort(dp); return dp[len-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>子序列问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-322-零钱兑换]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode-322%2F</url>
    <content type="text"><![CDATA[LeetCode-322-零钱兑换1. 题目：零钱兑换 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 2. 解题：​ 使用动态规划，我们假设f(n)表示n需要的最少数量。 ​ 动态规划求最小值公式：f(n) = min{f(i) + f(n - i)}，而对于本题，我们需要根据所给的硬币来求最小值：f(n) = 1 + f(n - coins[i])。 ​ 为了方便计算，我们使用”自底向上”（从f(1)到f(amount)）和数组来存储数据，这样我们避免重复计算。 ​ 对于数组初始化，赋值为amount + 1，我们知道假设有硬币1，最多也只有amount。 代码：12345678910111213141516class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if (coins == null || coins.length == 0 || amount &lt; 0) return -1; if (amount == 0) return 0; int[] dp = new int[amount+1]; Arrays.fill(dp, amount+1); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.length; j++) &#123; if (i &gt;= coins[j]) dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]]); &#125; &#125; return (dp[amount] == amount+1) ? -1 : dp[amount]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-062-不同路径]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode-062%2F</url>
    <content type="text"><![CDATA[LeetCode-062-不同路径1. 题目：不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：*m 和 n* 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 2. 解题：​ 使用动态规划，我们假设path(i,j)表示从(i,j)位置到达终点的不同路径数。 ​ 我们知道如果想知道path(0,0)点的路径数，我们可以用path(1,0) + path(0,1)来求出其路径数，因此我们得到一个递推公式：path(i,j) = path(i+1,j) + path(i,j+1). ​ 我们发现path(1,0) = path(2,0) + path(1,1)和path(0,1) = path(1,1) + path(0,2)其中重复使用了path(1,1)因此我们需要记录每一个位置路径数，防止重复计算。 ​ 我们还发现，每次计算一个位置时，需要的是其下方和右方的位置，因此我们可以“自底向上”就是从终点出发，这样方便我们计算。 ​ 我们知道终点位置路径数为1，这样我们可以计算其上方，和其右方的位置，一次类推，我们可以求出起点位置的路径数。 ​ 我们需要注意边界问题，若当前位置没有下方或右方时，用0代替。 代码：1234567891011121314151617181920class Solution &#123; public static int uniquePaths(int m, int n) &#123; if (m &lt;=0 || n &lt;= 0) return 0; int[][] paths = new int[m][n]; for (int i = m-1; i &gt;= 0; i--) &#123; for (int j = n-1; j &gt;= 0; j--) &#123; if (i == m-1 &amp;&amp; j == n-1) &#123; paths[i][j] = 1; continue; &#125; int A = (i+1 &lt; m) ? paths[i+1][j] : 0; int B = (j+1 &lt; n) ? paths[i][j+1] : 0; paths[i][j] = A+B; &#125; &#125; return paths[0][0]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-055-跳跃游戏]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode-055%2F</url>
    <content type="text"><![CDATA[LeetCode-055-跳跃游戏1. 题目：跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 2. 解题：​ 使用贪心算法，使用max来记录能够跳跃的最远距离max{max, i + nums[i]}。 ​ 当max &gt;= nums.length是说明可以到达末尾； ​ 当i &gt; max说明到不了当前位置，则返回false。 代码：1234567891011121314class Solution &#123; public boolean canJump(int[] nums) &#123; int max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; max) return false; max = (max &gt; (nums[i] + i)) ? max : nums[i] + i; if (max &gt;= nums.length) return true; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-160-相交链表]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-160%2F</url>
    <content type="text"><![CDATA[LeetCode-160-相交链表1. 题目：相交链表 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 2. 解题：​ 如果两个链表有交点，则两个链表在交点后是共享所有结点。 ​ 假设链表l1的长度为x，链表l2的长度为y，(x&gt;y)，​ 则可以肯定l1的前(x-y)一定没有交点；此时从l1的第x-y节点开始，两链表有相同的长度，同时遍历两个链表，找出交点。 代码：12345678910111213141516171819202122232425262728293031323334353637public static ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode aHead = headA; ListNode bHead = headB; //链表a的长度 int lengthA = getLength(aHead); //链表b的长度 int lengthB = getLength(bHead); //截去多余的结点 while (lengthA &gt; lengthB) &#123; aHead = aHead.next; lengthA--; &#125; while (lengthB &gt; lengthA) &#123; bHead = bHead.next; lengthB--; &#125; //查找交点 while (aHead != null &amp;&amp; bHead != null) &#123; if (aHead == bHead) return aHead; aHead = aHead.next; bHead = bHead.next; &#125; return null; &#125; /* 求链表的长度 */ private static int getLength(ListNode head) &#123; ListNode headA = head; int length = 0; while (headA != null) &#123; length++; headA = headA.next; &#125; return length; &#125; 3. 优化：​ 我们会发现上边的代码很冗长，需要计算链表长度，还要截掉多余的节点。但是实际上我们最主要的目的是可以“同步”遍历两个链表，也就是让两个链表长度相等。 ​ 我们知道l1_length + l2_length == l2_length + l1_length。所以，我们可以两轮遍历，来得到l1+l2。 ​ 两个链表l1、l2，通过两轮遍历，第一轮l1到达结尾时，从l2的头结点出发，同样的l2到达结尾时，从l1的头结点出发。这样就抹除了长度差；第二轮用来找交点。 代码：1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode aHead = headA, bHead = headB; while (aHead != bHead) &#123; aHead = (aHead == null) ? headB : aHead.next; bHead = (bHead == null) ? headA : bHead.next; &#125; return aHead; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-081-搜索旋转排序数组II]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-081%2F</url>
    <content type="text"><![CDATA[LeetCode-081-搜索旋转排序数组II1. 题目：搜索旋转排序数组II 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2: 12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 2. 解题：​ 和搜索旋转排序数组不同的是出现了重复元素，而且可能重复元素是旋转点，因此使用二分法查找旋转点就会变得复杂。 ​ 最简单的方法直接遍历一遍，看是否存在target. 代码：12345678910class Solution &#123; public boolean search(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (target == nums[i]) &#123; return true; &#125; &#125; return false; &#125;&#125; 3. 优化：​ 对与遍历进行优化，实际上仍然是遍历一遍，但是是从尾向前遍历，这样如果大于尾部元素，则有可能结果在数组前半部分，这时从头遍历，可以提高效率。 代码：123456789101112131415161718class Solution &#123; public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return false; if (nums.length == 1) return target == nums[0]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; if (nums[right] == target || nums[left] == target) return true; if (nums[right] &lt; target &amp;&amp; nums[left] &gt; target) return false; if (nums[right] &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>旋转排序数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-240-搜索二维矩阵 II]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-240%2F</url>
    <content type="text"><![CDATA[LeetCode-240-搜索二维矩阵 II1. 题目：搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 2. 解题：​ 这是一个特殊的矩阵，每一行是从小到大，每一列也是从小到大。因此我们可以知道矩阵的右上角是行的中最大的，也是列中最小的。 ​ 因此，我们可以每次都和矩阵的右上角元素比较： ​ target == matrix[row][col]返回true; ​ target &lt; matrix[row][col]说明肯定不在当前列，因此“删去当前列”，col-- ​ target &gt; matrix[row][col]说明肯定不在当前行，因此“删去当前行”，row++ 代码：123456789101112131415161718192021class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null) return false; if (matrix.length == 0) return false; if (matrix[0].length == 0) return false; int row = 0; int col = matrix[0].length - 1; while (row &lt; matrix.length &amp;&amp; col &gt;= 0) &#123; if (target == matrix[row][col]) &#123; return true; &#125; else if (target &lt; matrix[row][col]) &#123; col--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二维矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-328-奇偶链表]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode-328%2F</url>
    <content type="text"><![CDATA[LeetCode-328-奇偶链表1. 题目：奇偶链表 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 2. 解题： 使用一个计数器count用来记录奇偶。 使用两个指针oddHead，evenHead来记录奇偶节点。 将所有奇数位上的节点依次连接，将偶数上的节点依次连接。 最后将奇数的最后一个结点和偶数的第一个结点相连。 123456789101112131415161718192021222324252627282930313233343536373839public static ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null ) return head; //奇数的头结点 ListNode oddHead = null; //奇数的当前结点 ListNode oddCur = null; //偶数的头结点 ListNode evenHead = null; //偶数的当前结点 ListNode evenCur = null; //计数器 int count = 0; while (head != null) &#123; count++; //奇数结点 if ((count % 2) != 0) &#123; if (oddCur == null) &#123; oddCur = head; oddHead = oddCur; &#125; else &#123; oddCur.next = head; oddCur = oddCur.next; &#125; &#125; else &#123; //偶数节点 if (evenCur == null) &#123; evenCur = head; evenHead = evenCur; &#125; else &#123; evenCur.next = head; evenCur = evenCur.next; &#125; &#125; head = head.next; &#125; evenCur.next = null; oddCur.next = evenHead; return oddHead;&#125; 3. 优化：​ 奇偶结点不需要使用计数器．使用node.next和node.next.next。 1234567891011121314public static ListNode oddEvenList1(ListNode head) &#123; if (head == null) return null; //当前奇数结点，当前偶数结点，偶数头结点 ListNode odd = head, even = head.next, evenHead = even; while (even != null &amp;&amp; even.next != null) &#123; odd.next = odd.next.next; odd = odd.next; even.next = even.next.next; even = even.next; &#125; odd.next = evenHead; return head; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>奇偶链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-033－搜索旋转排序数组]]></title>
    <url>%2F2019%2F03%2F28%2FLeetCode-033%2F</url>
    <content type="text"><![CDATA[LeetCode-033-搜索旋转排序数组1. 题目：搜索旋转排序数组 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 2. 解题：​ 一个升序数组被旋转后其实是变成两个升序数组，所以我们可以使用二分法查找。总体思路有两步： ​ a) 找到旋转点，也就是最小的点min，使用二分法查找。 ​ b) 通过旋转点将数组分为两个升序数组，分别使用二分法查找。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int search(int[] nums, int target) &#123; //最小值的索引 int min = -1; int left = 0; int right = nums.length - 1; //用来找最小值 while (left &lt; right) &#123; //使用位运算除２ int mid = left + ((right - left) &gt;&gt;&gt; 1); //如果mid &lt; right说明最小值在右边 if (nums[mid] &lt; nums[right]) &#123; right = mid; &#125; else &#123; //说明最小值在左边 left = mid + 1; &#125; &#125; min = left; int indexLeft = BinarySearch(nums, 0, min - 1, target); int indexRight = BinarySearch(nums, min, nums.length-1, target); return (indexLeft == -1) ? indexRight : indexLeft; &#125; //使用二分法查找目标值 public int BinarySearch(int[] nums, int start, int end, int key) &#123; int left = start; int right = end; while (left &lt;= right) &#123; int mid = left + ((right - left) &gt;&gt;&gt; 1); if (nums[mid] == key) &#123; return mid; &#125; else if (nums[mid] &lt; key) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; &#125;&#125; 3. 注意：​ 我们需要注意一点：&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;的优先级低于+, -。 ​ 因此我们用位运算来计算除以2的运算需要写成left + ((right - left) &gt;&gt;&gt; 1)不能写成left + (right - left) &gt;&gt;&gt; 1。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析HashMap（一）]]></title>
    <url>%2F2019%2F03%2F27%2FHashMap-1%2F</url>
    <content type="text"><![CDATA[解析HashMap（一）一、什么是HashMap​ oracle文档中的解释： Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. ​ 我们可以得到几个重要的性质： ​ １．基于哈希表的Map接口的实现。 ​ ２．它的key和value允许出现null。 ​ ３．非同步。 ​ ４．不保证映射顺序（插入顺序），也不保证该顺序不随时间的改变。 二、哈希表（散列表）１．什么是哈希表？​ 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，也就是我们常说的哈希函数，使得每个关键字key都有一个对应的存储位置f(key)。而使用散列技术将记录存储在一块连续的存储在一块连续的存储空间中，这快连续的空间就是散列表/哈希表。 ２．哈希函数的构造方法： 有两个原则： a)方便计算； b)散列地址分布均匀。 ​ 常见的方法：2.1 直接定地址法、2.2 数字分析法、2.3 平方取中法、2.4 折叠法、2.5 除留余数法、2.6 随机数法。 ３．哈希冲突​ 哈希冲突是指，当key1 ≠ key2时，出现了f(key1) ≠ f(key2)。 ​ 常见的解决办法有：开放定地址法、再散列函数法、链地址法（这也是HasnMap用来解决哈希冲突的办法）、公共溢出区法。 三、基于JDK 1.7源码解析１．数据结构​ 在JDK 7中HashMap是由数组＋链表实现数据存储的，综合两者的特性（数组寻址容易，插入删除困难；链表插入删除容易，寻址困难）实现了寻址容易，插入删除也容易。 ​ 我们可以把数组看成一排桶连接起来，所有hash到同一个桶中的key，他们对应的结点是通过链表连接起来。 ２．重要属性：12345678910111213141516171819202122232425//内部数组的默认初始容量，作为hashmap的初始容量，是2的4次方(16) static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //默认的最大容量，2的30次方 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认负载因子，当容器使用率达到这个75%的时候就扩容 static final float DEFAULT_LOAD_FACTOR = 0.75f; //当数组表还没扩容的时候，一个共享的空表对象 static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;; //内部数组表，用来装entry，大小只能是2的n次方 transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; //存储的键值对的个数 transient int size; /** * 扩容的临界点，如果当前容量达到该值，则需要扩容了 * 如果当前数组容量为0时（空数组），则该值作为初始化内部数组的初始容量 */ int threshold; //由构造函数传入的指定负载因子,用来表示哈希表在其容量自动增加之前可以达到多满的一种尺度。 final float loadFactor; //Hash的修改次数，用来快速失败 transient int modCount; //threshold的最大值 static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE; //计算hash值时候用，初始是0 transient int hashSeed = 0; ​ 其中我们要着重讨论一下size、capacity、loadFactor、threshold这几个变量。 ​ capacity就是当前可以容纳的最大数量，size表示当前实际“KV对”数量。需要注意的是，capacity的大小为2的幂，当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值（第一个比他大的2的幂）当做初始容量。 ​ HashMap有扩容机制，就是当达到扩容条件时会进行扩容，从16扩容到32、64、128… ​ 那么，这个扩容条件指的是什么呢？ ​ HashMap的扩容条件就是当HashMap中的元素个数size超过临界值threshold时就会自动扩容。 ​ 公式为：threshold = loadFactor * capacity。 内部类Entry:123456789101112//hashmap中每一个键值对都是存在Entry对象中，entry还存储了自己的hash值等信息static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; //键 final K key; //值 V value; //数组中每一项可能存储多个entry，而这些entry就是已链表的形式被存储，此next指向下一个entry Entry&lt;K,V&gt; next; //本entry的hash值 int hash; //...省略...&#125; ３．构造方法​ 我们在这里只介绍传入容量和负载因子的构造方法。 12345678910111213141516171819202122232425public HashMap(int initialCapacity, float loadFactor) &#123; //初始容量不能小于0 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); //初始容量不能大于默认的最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //负载因子不能小于0，且不能为“NaN”（NaN（“不是一个数字（Not a Number）”的缩写）） if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); //将传入的负载因子赋值给属性 this.loadFactor = loadFactor; /** * 此时并不会创建容器，因为没有传具体值。 * 当下次传具体值的时候，才会“根据这次的初始容量”，创建一个内部数组。 * 所以此次的初始容量只是作为下一次扩容（新建）的容量。 */ threshold = initialCapacity; //该方法只在LinkedHashMap中有实现，主要在构造函数初始化和clone、readObject中有调用。 init(); &#125; ​ 我们需要注意，HashMap在new后并不会立即分配数组,而是第一次put时初始化,类似ArrayList在第一次add时分配空间。 ４．put()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 存入一个键值对，如果key重复，则更新value * @param key 键 * @param value 值 * @return 如果存的是新key则返回null，如果覆盖了旧键值对，则返回旧value */ public V put(K key, V value) &#123; //如果数组为空，则新建数组，这时同时初始化容量 if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; //如果key为null，则把value放在table[0]中 if (key == null) //如果有则覆盖了旧value，则返回value，否则返回null return putForNullKey(value); //生成key所对应的hash值 int hash = hash(key); //根据hash值和数组的长度找到：该key所属entry在table中的位置i int i = indexFor(hash, table.length); /** * 数组中每一项存的都是一个链表， * 先找到i位置，然后循环该位置上的每一个entry， * 如果发现存在key与传入key相等，则替换其value。然后结束侧方法。 * 如果没有找到相同的key，则继续执行下一条指令，将此键值对存入链表头 */ for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; //map操作次数加一 modCount++; //查看是否需要扩容，并将该键值对存入指定下标的链表头中 addEntry(hash, key, value, i); //如果是新存入的键值对，则返回null return null; &#125; inflateTable(threshold)方法：​ 该方法是新建一个空的内部数组。 123456789101112131415/** * 新建一个空的内部数组 * @param toSize 新数组容量 */ private void inflateTable(int toSize) &#123; //内部数组的大小必须是2的n次方，所以要找到“大于”toSize的“最小的2的幂” int capacity = roundUpToPowerOf2(toSize); //下次扩容临界值 threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; //capacity根据初始化hashseed initHashSeedAsNeeded(capacity); &#125; roundUpToPowerOf2(int number)方法：​ 找到number的最小的２的幂。 1234567private static int roundUpToPowerOf2(int number) &#123; /* 当 1 &lt; number &lt; MAXIMUM_CAPACITY 时； 进行highestOneBit((number - 1)处理，得到大于number的最下２的幂 */ return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;&#125; Integer.highestOneBit(int i)方法：​ 用来获取最左边的bit（其余位为０）所代表的值。 123456789101112131415161718192021222324252627/*此方法使用 移位 和 或运算 来实现的首先我们需要知道1 | X = 1, 0 | X = X我们假设一个整数n的二进制为：１XXX XXXX (X表示可１可０)step 1 : i = 1XXX XXXX | 01XX XXXX = 11XX XXXXstep 2 : i = 11XX XXXX | 0011 XXXX = 1111 XXXXstep 3 : i = 1111 XXXX | 0000 1111 = 1111 1111step 4 : i = 1111 1111 | 0000 0000 = 1111 1111step 5 : i = 1111 1111 | 0000 0000 = 1111 1111step 6 : 1111 1111 - 0111 1111 = 1000 0000我们知道前五步是将n从最高位开始全部置为１第６步是将n变成只有最高位为１*/ public static int highestOneBit(int i) &#123; //step 1 i |= i &gt;&gt; 1; //step 2 i |= i &gt;&gt; 2; //step 3 i |= i &gt;&gt; 4; //step 4 i |= i &gt;&gt; 8; //step 5 i |= i &gt;&gt; 16; return i - (i &gt;&gt;&gt; 1); &#125; hash(Object key)方法​ 在HashMap中元素找到存储位置需要经过：Key-&gt;hashCode-&gt;hash-&gt;index。hash值是通过key自己的hashcode来得到的。 ​ 我们知道一般hashcode的位数比数组的长度要大，进行&amp;操作时，往往只能低位进行运算，这样就会增加哈希冲突，所以在hash()中通过移位和异或操作加入高位计算。 123456789101112131415161718final int hash(Object k) &#123; //相当于一个开关，hashSeed = 0时为关 int h = hashSeed; //如果key是字符串类型，就使用stringHash32来生成hash值 if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; /* 这也是我们平常说的扰动算法。 */ //一次散列 h ^= k.hashCode(); //二次散列 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; indexFor(int h, int length)方法：​ 返回hash值的索引，采用除模取余法，h &amp; (length-1)操作等价于hash % length操作， 但&amp;操作性能更优，不需要转成十进制。这时，就与容量要是２的幂有关系，之后会详细解答。 1234static int indexFor(int h, int length) &#123; //除模取余,相当于hash % length，&amp;速度更快 return h &amp; (length-1);&#125; 用位运算来代替取模运算，除了性能问题以外，还解决了负数问题。由于hashcode是int类型，有正有负，负数取模比较麻烦。使用二进制的位运算，不管hashcode是正还是负，length-1为正，则其二进制第一位为０，做按位＆运算，结果一定为正。 addEntry(int hash, K key, V value, int bucketIndex)​ 查看是否需要扩容，然后插入新节点，注意新节点插入在链表头。 123456789101112131415161718192021 /** * 查看是否需要扩容，然后添加新节点 * @param hash key的hash值 * @param key 结点内key * @param value 结点内value * @param bucketIndex 结点所在的table下标 */void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果当前键值对数量达到了临界值，并且下标位置不为空，则扩容table if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //容量扩容一倍 resize(2 * table.length); //由于数组扩容了，重新计算hash值 hash = (null != key) ? hash(key) : 0; //重新计算存储位置 bucketIndex = indexFor(hash, table.length); &#125; //将键值对与他的hash值作为一个entry，插入table的指定下标中的链表头中 createEntry(hash, key, value, bucketIndex); &#125; ​ 整个put的过程以及当中用到的几个重要的方法讲解结束，接下来我们顺着讲解扩容过程。 ５．resize()​ 我们上面学习了数组扩容的条件，数组扩容的大小，由于默认initHashSeedAsNeeded内开关都是关闭状态，所以一般情况下transfer不需要进行rehash，能减少一部分开销。 ​ 我们现在详细看一下其源码的实现： 1234567891011121314151617181920212223242526/** * 对数组扩容，即创建一个新数组，并将旧数组里的东西重新存入新数组 * @param newCapacity 新数组容量 */ void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果当前数组容量已经达到最大值了，则将扩容的临界值设置为Integer.MAX_VALUE(Integer.MAX_VALUE是容量的临界点) if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; //创建一个扩容后的新数组 Entry[] newTable = new Entry[newCapacity]; //将当前数组中的键值对存入新数组,initHashSeedAsNeeded根据内部数组长度初始化hashseed transfer(newTable, initHashSeedAsNeeded(newCapacity)); //用新数组替换旧数组 table = newTable; //计算下一个扩容临界点 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); &#125; transfer(Entry[] newTable, boolean rehash)​ 将现有数组中的内容重新通过hash计算存入新的数组。 ​ 采用了单链表头插入方式，同一个位置上的新元素总会被放在链表的头部位置。 12345678910111213141516171819202122232425262728293031/** * 将现有数组中的内容重新通过hash计算存入新数组 * @param newTable 新数组 * @param rehash */void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; //遍历现有数组中的每一个单链表的头entry for (Entry&lt;K,V&gt; e : table) &#123; //查找链表里的每一个entry while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; //默认情况是不需要 rehash 的 if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; //根据新的数组长度，重新计算此entry所在下标i int i = indexFor(e.hash, newCapacity); //将entry放入下标i处链表的头部（将新数组此处的原有链表存入entry的next指针） e.next = newTable[i]; //将链表存回下标i newTable[i] = e; //查看下一个entry e = next; &#125; &#125;&#125; 四、总结：​ 简单介绍了关于HashMap、哈希表相关知识，以及基于JDK1.7分析其源码，减少了其中几个主要的方法。 （JDK1.7） HashMap在new后不会立即分配数组空间，而是在第一次put时，通过inflateTable方法，同时第一次初始化容量也是在这时。 HashMap的数组大小一定是２的幂，初始默认大小为１６，如果自己new的时候传入的容量大小不是２的幂，会通过roundUpToPowerOf2方法算出大于指定容量的最下２的幂。 扩容条件是size &gt;= capacity * loadFactor，扩容大小为原容量的２倍。 HashMap处理哈希碰撞使用链地址法，使用头插法。 之后会带来《解析HashMap（二）——基于JDK1.8》。]]></content>
      <categories>
        <category>Java</category>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>JDK1.7</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-002-两数相加]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-002%2F</url>
    <content type="text"><![CDATA[LeetCode-002-两数相加１．题目：两数相加 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 ２．解题：​ 这个题大致思路很简单，就是将两个链表每个节点取出来相加作为一个新的节点，同时需要考虑进位的问题。节点相加大致有这三种情况： l1和l2都有节点； l1有节点，l2为null；或者l1有节点，l2为null。 l1和l2都没有节点，但是有进位。 因此我们为了方便处理，如果一个链表没有节点时，就给该链表一个0节点。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //进位 int carry = 0; //head头结点 ListNode head = null; //tmp临时结点 ListNode tmp = null; //两链表长度不一致时，将短链表用０结点补全 while (l1 != null || l2 != null || carry != 0) &#123; int num = carry + (l1 == null ? 0 : l1.val) + ( l2 == null ? 0 : l2.val); ListNode node = new ListNode(num % 10); carry = num / 10; if (tmp == null) &#123; //第一次相加 tmp = node; head = tmp; &#125; else &#123; tmp.next = node; tmp = tmp.next; &#125; l1 = (l1 == null ? null : l1.next); l2 = (l2 == null ? null : l2.next); &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-056-合并区间]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-056%2F</url>
    <content type="text"><![CDATA[LeetCode-056-合并区间１．题目：合并区间 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 ２．解题： 将intervals按照每个区间的start进行从大到小排序。我们使用Collections.sort()方法，但是需要重写Comparator的compare()方法。 将intervals的第一个元素放入解集result中。 遍历intervals剩下的元素，若当前元素的start≥解集最后一个元素的end,说明这两个区间存在重叠，进行合并（将解集最后一个元素的end取这两个区间中最大的）。 否则，说明不存在重叠，则将当前元素添加到result中。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; //解集 List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if (intervals == null || intervals.size() == 0) &#123; return result; &#125; //按区间的start进行排序 Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval in1, Interval in2) &#123; return in1.start - in2.start; &#125; &#125;); result.add(intervals.get(0)); for (int i = 1; i &lt; intervals.size(); i++) &#123; //当前区间 Interval temp = intervals.get(i); //解集的最后一个区间 Interval resLast = result.get(result.size() - 1); if (temp.start &lt;= resLast.end) &#123; //存在重叠 resLast.end = (resLast.end &gt; temp.end) ? resLast.end : temp.end; result.set(result.size() - 1, resLast); &#125; else &#123; //不存在重叠 result.add(temp); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Collections</tag>
        <tag>合并问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-334-递增的三元子序列]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode-334%2F</url>
    <content type="text"><![CDATA[LeetCode-334-递增的三元子序列１．题目：递增的三元子序列 给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。 数学表达式如下: 如果存在这样的 i, j, k, 且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。 示例 1: 12输入: [1,2,3,4,5]输出: true 示例 2: 12输入: [5,4,3,2,1]输出: false ２．解题：​ 我们需要找到一个三元递增序列，因为我们每次只能遍历一个变量nums[i]，所以我们需要其他两个变量first和second，如果满足first &lt; second &lt; nums[i]，则找到满足题意的子序列。 代码：123456789101112131415161718class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; if (nums.length &lt; 3) &#123; return false; &#125; int first = Integer.MAX_VALUE, second = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt; first) &#123; first = num; &#125; else if (num &gt; first &amp;&amp; num &lt; second) &#123; second = num; &#125; else if (num &gt; second) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>三元序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-034-在排序数组中查找元素的第一个和最后一个位置]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode-034%2F</url>
    <content type="text"><![CDATA[LeetCode-034-在排序数组中查找元素的第一个和最后一个位置１．题目：在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] ２．解题：​ 这是一个排好序的数组，我们只需要查找数组中是否存在target，如果存在返回该元素的第一个位置和最后一个位置。 ​ 查找很简单，我们使用二分查找，时间复杂度O(log n)。 ​ 我们得到索引后分别找到其第一个位置和最后一个位置的索引。 ​ 需要注意边界问题（index = 0和index = nums.length-1）. 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public static int[] searchRange(int[] nums, int target) &#123; //result[0]记录开始位置，result[1]记录结束位置 int index = -1; int low = 0; int high = nums.length - 1; //二分法查找targrt是否在数组中 while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (nums[mid] == target) &#123; index = mid; break; &#125; else if (nums[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; //target不在数组中 if (index == -1) &#123; return new int[]&#123;-1, -1&#125;; &#125; int start = index; int end = index; //寻找target的第一个位置 while (start &gt; 0) &#123; if (nums[start] == nums[start - 1]) &#123; start--; &#125; else &#123; break; &#125; &#125; //寻找targrt的最后一个位置 while (end &lt; nums.length - 1) &#123; if (nums[end] == nums[end + 1]) &#123; end++; &#125; else &#123; break; &#125; &#125; return new int[]&#123;start, end&#125;; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-215-数组中第k个最大元素]]></title>
    <url>%2F2019%2F03%2F25%2FLeetCode-251%2F</url>
    <content type="text"><![CDATA[LeetCode-215-数组中第k个最大元素１．题目数组中第k个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 ２．解题​ 这个题的大体思路很简单，将数组排序，从大到小排，则结果就是第k个元素（从小到大排，结果就是倒数第k个元素）。因此这道题就是考察数组排序算法。 ​ 这里选择了传统快排算法。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; quickSort(nums, 0, nums.length-1); return nums[nums.length - k]; &#125; public static void quickSort(int[] nums, int start, int end) &#123; if (start &gt;= end) return; //左指针 int left = start; //右指针 int right = nums.length - 1; //基准数 int key = nums[start]; while (left &lt; right) &#123; /*从right出发 在右边找出一个比key小的数 */ while (key &lt;= nums[right] &amp;&amp; right &gt; left) right--; //这时找到比key小的数，或者left &gt;= right if (left &lt; right) &#123; //将比key小的数放在前边 nums[left] = nums[right]; left++; &#125; /*从前往后出发 找到比key大的一个数 */ while (nums[left] &lt;= key &amp;&amp; left &lt; right) &#123; left++; &#125; //这时找到比key大的数，或者left &gt;= right if (left &lt; right) &#123; nums[right] = nums[left]; right--; &#125; &#125; //跳出循环时，left == right，找到key的位置 nums[left] = key; //以key为中心，将当前数组分为两部分 quickSort(nums, start, left-1); quickSort(nums, left+1, end); &#125;&#125; ３．优化​ 虽然传统快排比一般的排序，但是远不及Java中Arrays中的优化快排算法快。 ​ 只为AC的答案（手动滑稽）！ 123456class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length-k]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>QuickSort</tag>
        <tag>Top k</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-162-寻找峰值]]></title>
    <url>%2F2019%2F03%2F25%2FLeetCode-162%2F</url>
    <content type="text"><![CDATA[LeetCode-162-寻找峰值１．题目：寻找峰值 峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 ２．解题：​ 首先找峰值值类似于找最值（或者是局部最值）。因此我们可以看做找最大值，要满足 O(logN) 时间复杂度，我们可以使用二分法找最大值。 ​ 首先我们需要两个指针：left左指针和right右指针，mid为它们的中值。 ​ 满足条件nums[mid] &gt; nums[mid - 1] &amp;&amp; mid[mid] &gt; mid[mid + 1]，就说明找到峰值； ​ 当nums[mid] &lt; nums[mid + 1]说明目前是在峰值的左坡，则峰值一定在mid的右边； ​ 当nums[mid] &lt; nums[mid - 1]说明目前是在峰值的右坡，则峰值一定在mid的左边； ​ 此时并没有结束，由于出现了mid - 1和mid + 1，所以我们必须考虑边界问题，峰值问题是两边是无穷小，因此当我们遇到边界问题时，可以取Integer.MIN_VALUE。 代码：12345678910111213141516171819202122class Solution &#123; public int findPeakElement(int[] nums) &#123; if (nums.length &lt;= 0 || nums == null) return -1; if (nums.length == 1) return 0; int left = 0; int right = nums.length - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (nums[mid] &gt; ( mid - 1 &gt;= 0 ? nums[mid-1] : Integer.MIN_VALUE ) &amp;&amp; (nums[mid] &gt; ( mid + 1 &lt; nums.length ? nums[mid + 1] : Integer.MIN_VALUE)))&#123; return mid; &#125; else if (nums[mid] &lt; ( mid - 1 &gt;= 0 ? nums[mid-1] : Integer.MIN_VALUE )) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>Java</tag>
        <tag>峰值问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Arrays.asList()]]></title>
    <url>%2F2019%2F03%2F25%2FasList%2F</url>
    <content type="text"><![CDATA[浅谈Arrays.asList()１．什么Arrays.asList()？asList()是Arrays类中一个静态方法，主要作用是：将数组转换为list，也就是数组和集合连接在一起。 ２．关于其使用的几个注意事项：​ 使用该方法时会有几大“坑”，同学们一定要注意。 2.1 不支持集合的add和remove方法​ 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportOperationException异常。 ​ 因为从源码分析，asList的返回对象是一个Arrays的内部类ArrayList，并没有实现集合的修改方法。 ​ 源码： 123456789101112131415public class Arrays &#123; //... public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new Arrays.ArrayList(a); &#125; private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, Serializable &#123; //... ArrayList(E[] array) &#123; this.a = (Object[])Objects.requireNonNull(array) &#125; //... &#125; //...&#125; ​ 因此，在使用其方法时，必须确保其长度不再改变。 2.2 该方法不适用于基本数据类型数组​ 先给大家做个演示： 12345678public class AsListDemo &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3&#125;; List list = Arrays.asList(nums); System.out.println("list's size = " + list.size()); //结果：list's size = 1 &#125;&#125; ​ 我们发现和我们想的并不一样，我们认为list的大小应该为３，现在却是１。这是因为，在Arrays.asList中，该方法接受一个变长参数，一般可看做数组参数，但是因为int[]本身就是一个类型，所以nums变量作为参数传递时，编译器认为只传了一个变量，这个变量的类型是int[]，所以size为1。 ​ 基本类型是不能作为泛型的参数，按道理应该使用包装类型，但这里缺没有报错，因为数组是可以泛型化的，所以转换后在list中就有一个类型为int的数组。 2.3 该方法连接起来的数组和集合，只要修改其中一个，另一个也被修改。​ 注意:仅仅针对对象数组类型,基本数据类型数组不具备该特性 1234567891011public class AsListDemo &#123; public static void main(String[] args) &#123; String[] str = &#123;"Hello", "i'm", "Djt"&#125;; List&lt;String&gt; slist = Arrays.asList(str); System.out.println("str[2] = " + str[2]); // 结果 : str[2] = Djt slist.set(2, "djt"); System.out.println("str[2] = " + str[2]); // 结果 : str[2] = djt &#125;&#125; ​ 我们发现对slist进行修改，str中也发生了修改。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。slist和str都是引用，他们指向的是同一个数组，指向同一个存储空间。 ​ 如果要使用真正的ArrayList，用 ArrayList 的构造器可以将其转变成真正的 ArrayList。]]></content>
      <categories>
        <category>Java</category>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Arrays</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树(RBT)]]></title>
    <url>%2F2019%2F03%2F25%2Frbt%2F</url>
    <content type="text"><![CDATA[红黑树１．基本知识：1.1什么是红黑树？​ 红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪． ​ 和AVL树相比，AVL树是一棵严格的平衡树（它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1），它的所有子数都满足平衡二叉树的定义．因此，AVL树的查找效率很高，但是插入，删除旋转次数比红黑树多． 1.2红黑树的性质：​ a．每个结点都是红色或者黑色； ​ b．根结点是黑色． ​ c．每个叶结点都是黑色（注意这里的叶结点都是指空结点）； ​ d．如果一个结点是红色的，则它的两个儿子是黑色的； ​ e．对于每一个结点，从该结点到其叶子结点构成的所有路径上的黑结点个数相同． ２．TreeSet and TreeMap2.1总体介绍​ 红黑树应用之一就是Java集合类中TreeSet和TreeMap的实现．以TreeMap的源码为例来讲解红黑树． ​ 我们上边学习了红黑树的性质，但是当我们进行插入或者删除操作时，性质d，c可能会被破坏，因此我们需要进行调整使它成为一颗合格的红黑树． ​ 调整的方法一般有两类：颜色调整和结构调整（左旋，右旋）． 2.2预备知识2.2.1左旋​ 左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 ​ (图片暂时没有) ​ TreeMap源代码： 12345678910111213141516171819202122private void rotateLeft(TreeMap.Entry&lt;K, V&gt; p) &#123; if (p != null) &#123; TreeMap.Entry&lt;K, V&gt; r = p.right; p.right = r.left; if (r.left != null) &#123; r.left.parent = p; &#125; r.parent = p.parent; if (p.parent == null) &#123; this.root = r; &#125; else if (p.parent.left == p) &#123; p.parent.left = r; &#125; else &#123; p.parent.right = r; &#125; r.left = p; p.parent = r; &#125; &#125; 2.2.2右旋​ 右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 ​ TreeMap源代码： 12345678910111213141516171819202122private void rotateRight(TreeMap.Entry&lt;K, V&gt; p) &#123; if (p != null) &#123; TreeMap.Entry&lt;K, V&gt; l = p.left; p.left = l.right; if (l.right != null) &#123; l.right.parent = p; &#125; l.parent = p.parent; if (p.parent == null) &#123; this.root = l; &#125; else if (p.parent.right == p) &#123; p.parent.right = l; &#125; else &#123; p.parent.left = l; &#125; l.right = p; p.parent = l; &#125; &#125; 2.2.3寻找结点后继​ 对于一棵二叉查找树，给定节点t，其后继（树中比大于t的最小的那个元素）可以通过如下方式找到： t的右子树不空，则t的后继是其右子树中最小的那个元素（右子树中最左边的）。 t的右孩子为空，则t的后继是其第一个向左走的祖先。 后继节点在红黑树的删除操作中将会用到。 ​ TreeMap源代码： 123456789101112131415161718static &lt;K, V&gt; TreeMap.Entry&lt;K, V&gt; successor(TreeMap.Entry&lt;K, V&gt; t) &#123; if (t == null) &#123; return null; &#125; else &#123; TreeMap.Entry p; if (t.right != null) &#123; for(p = t.right; p.left != null; p = p.left) &#123; &#125; return p; &#125; else &#123; p = t.parent; for(TreeMap.Entry ch = t; p != null &amp;&amp; ch == p.right; p = p.parent) &#123; ch = p; &#125; return p; &#125; &#125; &#125; 2.3主要方法分析2.3.1 get()​ get(Object key)根据key找到指定键值的value，或者null.该方法中核心是通过getEntry(Object key)来的到entry，然后返回entry.value． ​ 算法思想是根据key的自然顺序（或比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry． ​ get()源码： 1234public V get(Object key) &#123; TreeMap.Entry&lt;K, V&gt; p = this.getEntry(key); return p == null ? null : p.value; &#125; ​ getEntry()源码： 12345678910111213141516171819202122final TreeMap.Entry&lt;K, V&gt; getEntry(Object key) &#123; if (this.comparator != null) &#123; return this.getEntryUsingComparator(key); &#125; else if (key == null) &#123; throw new NullPointerException(); &#125; else &#123; Comparable&lt;? super K&gt; k = (Comparable)key; TreeMap.Entry p = this.root; while(p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) &#123; p = p.left; &#125; else &#123; if (cmp &lt;= 0) &#123; return p; &#125; p = p.right; &#125; &#125; return null; &#125;&#125; 2.3.2 put()​ put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则替换旧值，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）． 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public V put(K key, V value) &#123; TreeMap.Entry&lt;K, V&gt; t = this.root; if (t == null) &#123; this.compare(key, key); this.root = new TreeMap.Entry(key, value, (TreeMap.Entry)null); this.size = 1; ++this.modCount; return null; &#125; else &#123; Comparator&lt;? super K&gt; cpr = this.comparator; int cmp; TreeMap.Entry parent; if (cpr != null) &#123; //按照比较器顺序 do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) &#123; t = t.left; &#125; else &#123; if (cmp &lt;= 0) &#123; return t.setValue(value); &#125; t = t.right; &#125; &#125; while(t != null); &#125; else &#123; //按照key的自然顺序查找 if (key == null) &#123; throw new NullPointerException(); &#125; Comparable k = (Comparable)key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) &#123; t = t.left; &#125; else &#123; //若之前有，用新值替换旧值 if (cmp &lt;= 0) &#123; return t.setValue(value); &#125; t = t.right; &#125; &#125; while(t != null); &#125; //创建并插入新的entry TreeMap.Entry&lt;K, V&gt; e = new TreeMap.Entry(key, value, parent); if (cmp &lt; 0) &#123; parent.left = e; &#125; else &#123; parent.right = e; &#125; //调整红黑树 this.fixAfterInsertion(e); ++this.size; ++this.modCount; return null; &#125; &#125; ​ 上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）．难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。 ​ 在介绍该方法之前，我们先来学习一下关于红黑树的插入操作： 红黑树的插入：​ 首先，插入的结点默认为红色．为何？可以从两个方面来解释：一，由性质d我们知道红黑树中黑节点至少是红节点的两倍，因此插入节点的父节点为黑色的概率较大，而此时并不需要作任何调整，因此效率较高；二，由性质e我们可以知道，当我们插入红色结点时，破坏的性质少，性质e并没有被破坏． ​ 插入过程： 123456789101112131415161718192021１．父为黑 插入后无需任何操作．由于黑节点个数至少为红节点的两倍，因此父为黑的情况较多，而这种情况在插入后一般无需任何调整．２．父为红 这时红黑树的性质被破坏，此时我们需要根据叔叔结点（和父结点有同一父亲的结点）的颜色分情况讨论．2.1 叔叔为红 只需交换爸爸、叔叔和爷爷的颜色即可．（父＝black, 叔＝black，爷＝red） 此时若爷爷节点和太爷爷节点颜色相同，再以爷爷节点为起始节点，进行刚才相同的操作．2.2 叔叔为黑此时分四种情况：a)爸爸在左，叔叔在右，我在左 对爷爷结点，进行一次R旋转．（旋转后爸爸为根结点）b)爸爸在左，叔叔在右，我在左 对父亲结点，进行一次L旋转； 对爷爷结点，进行一次R旋转．（旋转后我为根结点） （此时，多进行一次L旋转）c)叔叔在左、爸爸在右、我在右 对爷爷结点，进行一次L旋转．（旋转后爸爸为根结点）d)叔叔在左、爸爸在右、我在左 对父亲结点，进行一次R旋转； 对爷爷结点，进行一次L旋转．（旋转后我为根结点）要注意旋转完进行颜色调整． ​ 现在我们来看看fixAfterInsertion()的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243private void fixAfterInsertion(TreeMap.Entry&lt;K, V&gt; x) &#123; x.color = false; //false == red 插入的新结点为红结点 while(x != null &amp;&amp; x != this.root &amp;&amp; !x.parent.color) &#123; //爸爸结点为红 TreeMap.Entry y; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; //爸爸结点在左 y = rightOf(parentOf(parentOf(x))); //叔叔结点在右 if (!colorOf(y)) &#123; //叔叔结点为红 setColor(parentOf(x), true); setColor(y, true); setColor(parentOf(parentOf(x)), false); x = parentOf(parentOf(x)); &#125; else &#123; //叔叔结点为黑 if (x == rightOf(parentOf(x))) &#123; //爸爸在左，叔叔在右，我在右 x = parentOf(x); this.rotateLeft(x); &#125; //爸爸在左，叔叔在右，我在左 setColor(parentOf(x), true); setColor(parentOf(parentOf(x)), false); this.rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; //爸爸结点在右 y = leftOf(parentOf(parentOf(x))); //叔叔结点在左 if (!colorOf(y)) &#123; //叔叔结点为红 setColor(parentOf(x), true); setColor(y, true); setColor(parentOf(parentOf(x)), false); x = parentOf(parentOf(x)); &#125; else &#123; //叔叔结点为黑 if (x == leftOf(parentOf(x))) &#123; //叔叔在左、爸爸在右、我在左 x = parentOf(x); this.rotateRight(x); &#125; //叔叔在左、爸爸在右、我在右 setColor(parentOf(x), true); setColor(parentOf(parentOf(x)), false); this.rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; //爸爸结点为黑，不调整 this.root.color = true; &#125; 2.3.3 remove()​ remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry．由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整． ​ getEntry()函数上面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整． ​ 我们先来看看红黑树的删除操作． 红黑树的删除：​ 由于红黑树是一棵改良版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整．现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况： 删除点p的左右子树都为空，或者只有一棵子树非空。 删除点p的左右子树都非空。 ​ 对于上述＂情况1＂处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）； ​ 对于＂情况2＂可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）． ​ 我们来看看deleteEntry()源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void deleteEntry(TreeMap.Entry&lt;K, V&gt; p) &#123; ++this.modCount; --this.size; TreeMap.Entry replacement; if (p.left != null &amp;&amp; p.right != null) &#123; //双子树都为非空，情况２ replacement = successor(p); //找到p的后继 /*将后继复制到p上，相当于已经把原来p删除，现在目的是需要把原来结点的后继删除 需要注意的是，只是修改了原结点的k，value，但是结点的颜色并没有改变 删除操作的对象已经完全变成原来的后继结点 */ p.key = replacement.key; p.value = replacement.value; //p指向后继结点 p = replacement; &#125; //如果p有左子结点，找到左字节点，否则用右子结点 replacement = p.left != null ? p.left : p.right; if (replacement != null) &#123; //p结点有一个子树 //将p的父结点设置为replacement的父结点 replacement.parent = p.parent; //将p的子结点和p的父结点向连 if (p.parent == null) &#123; //p本身就是根结点 this.root = replacement; &#125; else if (p == p.parent.left) &#123; p.parent.left = replacement; &#125; else &#123; p.parent.right = replacement; &#125; //将p结点删除 p.left = p.right = p.parent = null; //p为黑结点，需要调整树 if (p.color) &#123; this.fixAfterDeletion(replacement); &#125; &#125; else if (p.parent == null) &#123; //若p为空，则树为空 this.root = null; &#125; else &#123; //被删除的结点为叶子结点 if (p.color) &#123; this.fixAfterDeletion(p); &#125; //直接删除该叶子结点p if (p.parent != null) &#123; if (p == p.parent.left) &#123; p.parent.left = null; &#125; else if (p == p.parent.right) &#123; p.parent.right = null; &#125; p.parent = null; &#125; &#125; &#125; ​ 当结点被删除后，红黑树需要考虑是否需要调整．我们发现，如果删除的是红色结点，并不会破坏红黑树的性质．只有删除点是黑结点的时候，才会触发调整函数， ​ 跟上文中讲过的fixAfterInsertion()函数一样，fixAfterDeletion(Entry&lt;K,V&gt; x)也要分成若干种情况．记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转． ​ 删除黑结点后的调整情况． 12345678910111213141516171819202122232425262728293031323334我们先假设：P为删除的结点；x为P的子结点，x会覆盖到P的位置；sib为P的兄弟结点，同时也是x现在兄弟结点；pp为sib和x(p)父结点；1 x为红色时，直接覆盖，保留父结点的颜色（黑色）．2 x为黑色时，此时需要考虑sib 2.1 sib为红色的时候：(此时，pp一定为黑) 2.1.1 x在左，sib在右 sib黑，pp红，并对pp进行左旋； 这时，现sib = 原来sib.left 2.1.2 x在右，sib在左 sib黑，pp红，并对pp进行右旋； 这时，现sib = 原来sib.right 2.2 sib为黑时（不能判断pp的颜色） 2.2.1 pp红，sib的两子结点为黑 sib红，pp黑 （此时，x和sib的左右顺序无关） 2.2.1 pp黑，sib的两子结点为黑 sib红，pp黑 （此时，x和sib的左右顺序无关） 2.2.3 pp颜色随意，sib至少有一个红子结点 2.2.3.1 红侄为左左（sib左，sib左儿子红） 没有删除之前，pp的右边至少两个黑结点，现在为１个 对sib进行右旋 红侄为黑，交换sib和pp的颜色． 2.2.3.2 红侄为左右（sib左，sib右儿子红） 对sib进行左旋，对pp进行右旋，将红侄移到子数的根结点 红侄染成pp颜色，pp为黑色 2.2.3.3 红侄为右右（sib右，sib右儿子红） 对sib进行左旋， 红侄为黑，交换sib和pp的颜色． 2.2.3.4 红侄为右左（sib右，sib左儿子红） 对sib进行右旋，对pp进行左旋，将红侄移到子数的根结点 红侄染成pp颜色，pp为黑色 ​ 我们现在来看看fixAfterDeletion()源码，大致分类情况相同，有些细节进行了优化． 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private void fixAfterDeletion(TreeMap.Entry&lt;K, V&gt; x) &#123; //当x为根结点 或者 x为红结点时，直接染成黑结点即可 while(x != this.root &amp;&amp; colorOf(x)) &#123; //当x为黑 且 不是根结点 TreeMap.Entry sib; if (x == leftOf(parentOf(x))) &#123; //x为pp的左儿子 sib = rightOf(parentOf(x)); //sib为pp的右儿子 if (!colorOf(sib)) &#123; //sib为红 2.2.1//--情况１ setColor(sib, true); setColor(parentOf(x), false); this.rotateLeft(parentOf(x)); sib = rightOf(parentOf(x));//现sib = 原来sib.left//情况１-- &#125; // sib一定为黑（没有进入上一个if 或者 sib为红，则它的子结点一定为黑） //--情况2 if (colorOf(leftOf(sib)) &amp;&amp; colorOf(rightOf(sib))) &#123; //此时，只需让sib为红，就能满足pp为根结点的子数左右黑结点数相同（2-1 == 2-1） setColor(sib, false); //pp的结点颜色不确定，让x指向x.parent，若为红直接跳出，若为黑，继续进入循环 x = parentOf(x);//情况2-- &#125; else &#123;// sib为黑，sib子结点至少有一个为红 if (colorOf(rightOf(sib))) &#123;//2.2.3.4//--情况3 setColor(leftOf(sib), true); setColor(sib, false); this.rotateRight(sib); sib = rightOf(parentOf(x));//情况3-- &#125;//--情况4 setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), true); setColor(rightOf(sib), true); this.rotateLeft(parentOf(x)); x = this.root;//情况4-- &#125; &#125; else &#123; //与上边对称 sib = leftOf(parentOf(x)); if (!colorOf(sib)) &#123;//--情况5 setColor(sib, true); setColor(parentOf(x), false); this.rotateRight(parentOf(x)); sib = leftOf(parentOf(x));//情况5-- &#125; if (colorOf(rightOf(sib)) &amp;&amp; colorOf(leftOf(sib))) &#123;//情况6 setColor(sib, false); x = parentOf(x);//情况6-- &#125; else &#123; if (colorOf(leftOf(sib))) &#123;//--情况7 setColor(rightOf(sib), true); setColor(sib, false); this.rotateLeft(sib); sib = leftOf(parentOf(x));//情况7-- &#125;//--情况8 setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), true); setColor(leftOf(sib), true); this.rotateRight(parentOf(x)); x = this.root;//情况8-- &#125; &#125; &#125; setColor(x, true); &#125; ​ 我们分析代码可以知道，如果进入循环中的情况一，将情况1首先转换成情况2，或者转换成情况3和情况4。当然，并不意味着调整过程一定是从情况1开始．通过后续代码我们还会发现几个有趣的规则： ​ a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）； ​ b).一旦进入情况3和情况4，一定会退出循环（因为x为root）． ​ c).情况3其实是落在情况4内的． ​ d).情况5～情况8跟前四种情况是对称的． 参考资料： https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md https://blog.csdn.net/qq_34173549/article/details/79636764]]></content>
      <categories>
        <category>Java</category>
        <category>集合类</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
</search>
